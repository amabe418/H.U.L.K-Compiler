==============================================================
======================AST=====================================
==============================================================
// ast.hpp
#pragma once

#ifndef AST_HPP
#define AST_HPP

#include <cmath>
#include <memory>
#include <optional>
#include <string>
#include <vector>

#include "../Types/type_info.hpp"
#include "visitor.hpp"

struct Program;
struct NumberExpr;
struct StringExpr;
struct BooleanExpr;
struct UnaryExpr;
struct BinaryExpr;
struct CallExpr;
struct VariableExpr;
struct LetExpr;
struct Stmt;
struct ExprStmt;
struct AssignExpr;
struct FunctionDecl;
struct IfExpr;
struct ExprBlock;
struct WhileExpr;
struct BaseCallExpr;

struct TypeDecl;
struct AttributeDecl;
struct MethodDecl;
struct NewExpr;
struct GetAttrExpr;
struct SetAttrExpr;
struct MethodCallExpr;
struct SelfExpr;

struct Instance;

// Base class for all expression nodes
struct Expr
{
    std::shared_ptr<TypeInfo> inferredType;
    virtual void accept(ExprVisitor* v) = 0;
    virtual ~Expr() = default;
};

using ExprPtr = std::unique_ptr<Expr>;

// base class for all statement nodes.
struct Stmt
{
    std::shared_ptr<TypeInfo> inferredType;
    virtual void accept(StmtVisitor*) = 0;
    virtual ~Stmt() = default;
};

using StmtPtr = std::unique_ptr<Stmt>;

// program: father of all the statements
struct Program : Stmt
{
    std::vector<StmtPtr> stmts;
    void
    accept(StmtVisitor* v) override
    {
        v->visit(this);
    }
};

// evaluates an expression
struct ExprStmt : Stmt
{
    ExprPtr expr;
    ExprStmt(ExprPtr e) : expr(std::move(e)) {}
    void
    accept(StmtVisitor* v) override
    {
        v->visit(this);
    }
};

// Literal: numeric
struct NumberExpr : Expr
{
    double value;
    NumberExpr(double v) : value(v) {}
    void
    accept(ExprVisitor* v) override
    {
        v->visit(this);
    }
};

// Literal: string
struct StringExpr : Expr
{
    std::string value;
    StringExpr(const std::string& s) : value(s) {}
    void
    accept(ExprVisitor* v) override
    {
        v->visit(this);
    }
};

// Literal: bool
struct BooleanExpr : Expr
{
    bool value;
    BooleanExpr(bool v) : value(v) {}
    void
    accept(ExprVisitor* v) override
    {
        v->visit(this);
    }
};

// Unary operation: e.g., negation
struct UnaryExpr : Expr
{
    enum Op
    {
        OP_NEG
    } op;
    ExprPtr operand;
    UnaryExpr(Op o, ExprPtr expr) : op(o), operand(std::move(expr)) {}
    void
    accept(ExprVisitor* v) override
    {
        v->visit(this);
    }
};

// Binary operation: +, -, *, /, ^, comparisons, mod
struct BinaryExpr : Expr
{
    enum Op
    {
        OP_ADD,
        OP_SUB,
        OP_MUL,
        OP_DIV,
        OP_POW,
        OP_MOD,
        OP_LT,
        OP_GT,
        OP_LE,
        OP_GE,
        OP_EQ,
        OP_NEQ,
        OP_OR,
        OP_AND,
        OP_CONCAT,
        OP_CONCAT_WS
    } op;
    ExprPtr left;
    ExprPtr right;
    BinaryExpr(Op o, ExprPtr l, ExprPtr r) : op(o), left(std::move(l)), right(std::move(r)) {}
    void
    accept(ExprVisitor* v) override
    {
        v->visit(this);
    }
};

// Function call: sqrt, sin, cos, exp, log, rand
struct CallExpr : Expr
{
    std::string callee;
    std::vector<ExprPtr> args;
    CallExpr(const std::string& name, std::vector<ExprPtr>&& arguments)
        : callee(name), args(std::move(arguments))
    {
    }
    void
    accept(ExprVisitor* v) override
    {
        v->visit(this);
    }
};

// **VariableExpr**: para referirse a un identificador
struct VariableExpr : Expr
{
    std::string name;
    VariableExpr(const std::string& n) : name(n) {}
    void
    accept(ExprVisitor* v) override
    {
        v->visit(this);
    }
};

// **LetExpr**: let <name> = <init> in <body>
struct LetExpr : Expr
{
    std::string name;     // nombre de la variable
    ExprPtr initializer;  // expresión inicializadora
    StmtPtr body;         // cuerpo donde la variable está en alcance
    LetExpr(const std::string& n, ExprPtr init, StmtPtr b)
        : name(n), initializer(std::move(init)), body(std::move(b))
    {
    }
    void
    accept(ExprVisitor* v) override
    {
        v->visit(this);
    }
};

// a := b  destructive assignment
struct AssignExpr : Expr
{
    std::string name;
    ExprPtr value;

    AssignExpr(const std::string& n, ExprPtr v) : name(n), value(std::move(v)) {}

    void
    accept(ExprVisitor* v) override
    {
        v->visit(this);
    }
};

// for function's declaration
struct FunctionDecl : Stmt
{
    std::string name;

    // Lista de nombres de parámetros
    std::vector<std::string> params;

    // Tipos anotados por el usuario (puede haber inferencia si std::nullopt)
    std::vector<std::optional<std::shared_ptr<TypeInfo>>> paramTypes;

    // Tipo de retorno anotado (opcional)
    std::optional<std::shared_ptr<TypeInfo>> returnType;

    // Cuerpo de la función (Expr simple o ExprBlock)
    StmtPtr body;

    FunctionDecl(const std::string& n, std::vector<std::string>&& p, StmtPtr b,
                 std::vector<std::optional<std::shared_ptr<TypeInfo>>>&& pt = {},
                 std::optional<std::shared_ptr<TypeInfo>> rt = std::nullopt)
        : name(n),
          params(std::move(p)),
          paramTypes(std::move(pt)),
          returnType(std::move(rt)),
          body(std::move(b))
    {
    }

    void
    accept(StmtVisitor* v) override
    {
        v->visit(this);
    }
};

// if-else expressions:
struct IfExpr : Expr
{
    ExprPtr condition;
    ExprPtr thenBranch;
    ExprPtr elseBranch;

    IfExpr(ExprPtr cond, ExprPtr thenB, ExprPtr elseB)
        : condition(std::move(cond)), thenBranch(std::move(thenB)), elseBranch(std::move(elseB))
    {
    }

    void
    accept(ExprVisitor* v) override
    {
        v->visit(this);
    }
};

// bloques de expresiones
struct ExprBlock : Expr
{
    std::vector<StmtPtr> stmts;
    ExprBlock(std::vector<StmtPtr>&& s) : stmts(std::move(s)) {}
    void
    accept(ExprVisitor* v) override
    {
        v->visit(this);
    }
};

// patra ciclos while
struct WhileExpr : Expr
{
    ExprPtr condition;
    ExprPtr body;

    WhileExpr(ExprPtr cond, ExprPtr b) : condition(std::move(cond)), body(std::move(b)) {}

    void
    accept(ExprVisitor* v) override
    {
        v->visit(this);
    }
};

// type A
struct TypeDecl : Stmt
{
    std::string name;
    std::vector<std::string> params;
    std::vector<std::unique_ptr<AttributeDecl>> attributes;
    std::vector<std::unique_ptr<MethodDecl>> methods;

    // HERENCIA
    std::string baseType = "Object";
    std::vector<ExprPtr> baseArgs;

    TypeDecl(std::string n, std::vector<std::string>&& params_,
             std::vector<std::unique_ptr<AttributeDecl>> attrs,
             std::vector<std::unique_ptr<MethodDecl>> meths, std::string base = "Object",
             std::vector<ExprPtr>&& args = {})
        : name(std::move(n)),
          params(std::move(params_)),
          attributes(std::move(attrs)),
          methods(std::move(meths)),
          baseType(std::move(base)),
          baseArgs(std::move(args))
    {
    }

    void
    accept(StmtVisitor* v) override
    {
        v->visit(this);
    }
    const std::vector<std::string>&
    getParams() const
    {
        return params;
    }
};
// atributos de tipos
struct AttributeDecl
{
    std::string name;
    ExprPtr initializer;
    AttributeDecl(std::string n, ExprPtr expr) : name(std::move(n)), initializer(std::move(expr)) {}
};

// metodos de tipos
struct MethodDecl : Stmt
{
    std::string name;
    std::vector<std::string> params;
    StmtPtr body;

    MethodDecl(const std::string& n, std::vector<std::string>&& p, StmtPtr b)
        : name(n), params(std::move(p)), body(std::move(b))
    {
    }

    void
    accept(StmtVisitor* v) override
    {
        v->visit(this);
    }
};

struct NewExpr : Expr
{
    std::string typeName;
    std::vector<ExprPtr> args;  // nuevos

    // Constructor con lista de argumentos
    NewExpr(std::string name, std::vector<ExprPtr>&& args_)
        : typeName(std::move(name)), args(std::move(args_))
    {
    }

    void
    accept(ExprVisitor* v) override
    {
        v->visit(this);
    }
};

struct GetAttrExpr : Expr
{
    ExprPtr object;
    std::string attrName;

    GetAttrExpr(ExprPtr obj, std::string attr) : object(std::move(obj)), attrName(std::move(attr))
    {
    }

    void
    accept(ExprVisitor* v) override
    {
        v->visit(this);
    }
};

struct SetAttrExpr : Expr
{
    ExprPtr object;
    std::string attrName;
    ExprPtr value;

    SetAttrExpr(ExprPtr obj, std::string attr, ExprPtr val)
        : object(std::move(obj)), attrName(std::move(attr)), value(std::move(val))
    {
    }

    void
    accept(ExprVisitor* v) override
    {
        v->visit(this);
    }
};

struct MethodCallExpr : Expr
{
    ExprPtr object;
    std::string methodName;
    std::vector<ExprPtr> args;

    MethodCallExpr(ExprPtr obj, std::string method, std::vector<ExprPtr>&& arguments)
        : object(std::move(obj)), methodName(std::move(method)), args(std::move(arguments))
    {
    }

    void
    accept(ExprVisitor* v) override
    {
        v->visit(this);
    }
};

struct SelfExpr : Expr
{
    void
    accept(ExprVisitor* v) override
    {
        v->visit(this);
    }
};

struct BaseCallExpr : Expr
{
    std::vector<ExprPtr> args;
    BaseCallExpr(std::vector<ExprPtr>&& a) : args(std::move(a)) {}

    void
    accept(ExprVisitor* v) override
    {
        v->visit(this);
    }
};

#endif  // AST_HPP


==============================================================
======================TYPE INFO=====================================
==============================================================
// type_info.hpp
#pragma once

#include <memory>
#include <string>
#include <unordered_map>
#include <vector>

// Forward declaration
struct FunctionDecl;

struct TypeInfo
{
    enum class Kind
    {
        Int,
        Float,
        Bool,
        String,
        Void,
        Function,
        Class,
        Error,
        Any
    };

    Kind kind;
    std::string name;
    std::vector<std::shared_ptr<TypeInfo>> paramTypes;
    std::shared_ptr<TypeInfo> returnType;
    std::unordered_map<std::string, std::shared_ptr<TypeInfo>> attributes;
    std::unordered_map<std::string, std::shared_ptr<TypeInfo>> methods;
    std::shared_ptr<TypeInfo> baseType;

    TypeInfo() : kind(Kind::Error), baseType(nullptr) {}
    TypeInfo(Kind k) : kind(k), baseType(nullptr) {}
    TypeInfo(Kind k, const std::string& n) : kind(k), name(n), baseType(nullptr) {}
    TypeInfo(Kind k, const std::vector<std::shared_ptr<TypeInfo>>& params,
             const std::shared_ptr<TypeInfo>& ret)
        : kind(k), paramTypes(params), returnType(ret), baseType(nullptr)
    {
    }
    TypeInfo(Kind k, const std::string& n, const std::shared_ptr<TypeInfo>& base)
        : kind(k), name(n), baseType(base)
    {
    }

    static std::shared_ptr<TypeInfo>
    Int()
    {
        return std::make_shared<TypeInfo>(Kind::Int);
    }
    static std::shared_ptr<TypeInfo>
    Float()
    {
        return std::make_shared<TypeInfo>(Kind::Float);
    }
    static std::shared_ptr<TypeInfo>
    Bool()
    {
        return std::make_shared<TypeInfo>(Kind::Bool);
    }
    static std::shared_ptr<TypeInfo>
    String()
    {
        return std::make_shared<TypeInfo>(Kind::String);
    }
    static std::shared_ptr<TypeInfo>
    Void()
    {
        return std::make_shared<TypeInfo>(Kind::Void);
    }
    static std::shared_ptr<TypeInfo>
    Error()
    {
        return std::make_shared<TypeInfo>(Kind::Error);
    }
    static std::shared_ptr<TypeInfo>
    Any()
    {
        return std::make_shared<TypeInfo>(Kind::Any);
    }
    static std::shared_ptr<TypeInfo>
    Function(const std::vector<std::shared_ptr<TypeInfo>>& params,
             const std::shared_ptr<TypeInfo>& ret)
    {
        return std::make_shared<TypeInfo>(Kind::Function, params, ret);
    }
    static std::shared_ptr<TypeInfo>
    Class(const std::string& name, const std::shared_ptr<TypeInfo>& base)
    {
        return std::make_shared<TypeInfo>(Kind::Class, name, base);
    }
    static std::shared_ptr<TypeInfo>
    Object()
    {
        return std::make_shared<TypeInfo>(Kind::Class, "Object", nullptr);
    }
    static std::shared_ptr<TypeInfo>
    UserDefined(const std::string& name)
    {
        return std::make_shared<TypeInfo>(Kind::Class, name, nullptr);
    }

    bool
    isFunction() const
    {
        return kind == Kind::Function;
    }
    bool
    isClass() const
    {
        return kind == Kind::Class;
    }
    bool
    hasBase() const
    {
        return baseType != nullptr;
    }

    const std::vector<std::shared_ptr<TypeInfo>>&
    getParamTypes() const
    {
        return paramTypes;
    }
    const std::shared_ptr<TypeInfo>&
    getReturnType() const
    {
        return returnType;
    }
    const std::shared_ptr<TypeInfo>*
    getAttributeType(const std::string& name) const
    {
        auto it = attributes.find(name);
        return it != attributes.end() ? &it->second : nullptr;
    }
    const std::shared_ptr<TypeInfo>*
    getMethodType(const std::string& name) const
    {
        auto it = methods.find(name);
        return it != methods.end() ? &it->second : nullptr;
    }
    const std::shared_ptr<TypeInfo>*
    getBaseMethodType(const std::string& name) const
    {
        return baseType ? baseType->getMethodType(name) : nullptr;
    }

    void
    addAttribute(const std::string& name, const std::shared_ptr<TypeInfo>& type)
    {
        attributes[name] = type;
    }

    void
    addMethod(const std::string& name, const std::shared_ptr<TypeInfo>& type)
    {
        methods[name] = type;
    }

    void
    setConstructorParams(const std::vector<std::shared_ptr<TypeInfo>>& params)
    {
        paramTypes = params;
    }

    std::string
    toString() const
    {
        switch (kind)
        {
            case Kind::Int:
                return "Int";
            case Kind::Float:
                return "Float";
            case Kind::Bool:
                return "Bool";
            case Kind::String:
                return "String";
            case Kind::Void:
                return "Void";
            case Kind::Error:
                return "Error";
            case Kind::Any:
                return "Any";
            case Kind::Function:
            {
                std::string result = "Function(";
                for (size_t i = 0; i < paramTypes.size(); ++i)
                {
                    if (i > 0)
                        result += ", ";
                    result += paramTypes[i]->toString();
                }
                result += ") -> " + returnType->toString();
                return result;
            }
            case Kind::Class:
            {
                std::string result = name;
                if (baseType)
                {
                    result += " extends " + baseType->toString();
                }
                return result;
            }
            default:
                return "Unknown";
        }
    }

    bool
    operator==(const TypeInfo& other) const
    {
        if (kind != other.kind)
            return false;
        if (kind == Kind::Function)
        {
            if (paramTypes.size() != other.paramTypes.size())
                return false;
            for (size_t i = 0; i < paramTypes.size(); ++i)
            {
                if (*paramTypes[i] != *other.paramTypes[i])
                    return false;
            }
            return *returnType == *other.returnType;
        }
        if (kind == Kind::Class)
        {
            return name == other.name &&
                   ((!baseType && !other.baseType) ||
                    (baseType && other.baseType && *baseType == *other.baseType));
        }
        return true;
    }

    bool
    operator!=(const TypeInfo& other) const
    {
        return !(*this == other);
    }
};

==============================================================
======================tYPE CHECKER=====================================
==============================================================
// type_checker.hpp
#pragma once

#include <iostream>
#include <memory>
#include <stdexcept>
#include <string>
#include <unordered_map>
#include <vector>

#include "../AST/ast.hpp"
#include "../SymbolCollector/symbol_collector.hpp"
#include "../Symbols/symbol.hpp"
#include "../Symbols/symbol_table.hpp"
#include "type_info.hpp"

class TypeChecker : public ExprVisitor, public StmtVisitor
{
   public:
    TypeChecker() : symbols(SymbolTable::getInstance())
    {
        // Agregar funciones built-in
        addBuiltinFunction("print", {TypeInfo::Any()}, TypeInfo::Void());
        addBuiltinFunction("sqrt", {TypeInfo::Float()}, TypeInfo::Float());
        addBuiltinFunction("sin", {TypeInfo::Float()}, TypeInfo::Float());
        addBuiltinFunction("cos", {TypeInfo::Float()}, TypeInfo::Float());
        addBuiltinFunction("exp", {TypeInfo::Float()}, TypeInfo::Float());
        addBuiltinFunction("log", {TypeInfo::Float(), TypeInfo::Float()}, TypeInfo::Float());
        addBuiltinFunction("rand", {}, TypeInfo::Float());
    }

    bool
    check(Program* prog)
    {
        errors.clear();  // Clear any previous errors
        try
        {
            prog->accept(this);
            return errors.empty();
        }
        catch (const std::exception& e)
        {
            errors.push_back(std::string("Type error: ") + e.what());
            return false;
        }
    }

    const std::vector<std::string>&
    getErrors() const
    {
        return errors;
    }

    void
    error(const std::string& msg)
    {
        errors.push_back(msg);
    }

    std::shared_ptr<TypeInfo>
    getType(Expr* expr)
    {
        expr->accept(this);
        return currentType;
    }

    std::shared_ptr<TypeInfo>
    getType(Stmt* stmt)
    {
        stmt->accept(this);
        return currentType;
    }

    void
    visit(NumberExpr* expr) override
    {
        expr->inferredType = TypeInfo::Int();
    }
    void
    visit(StringExpr* expr) override
    {
        expr->inferredType = TypeInfo::String();
    }
    void
    visit(BooleanExpr* expr) override
    {
        expr->inferredType = TypeInfo::Bool();
    }

    void
    visit(VariableExpr* expr) override
    {
        if (auto s = symbols.lookup(expr->name))
        {
            expr->inferredType = s->type;
        }
        else
        {
            reportError("Undefined variable: " + expr->name);
            expr->inferredType = TypeInfo::Error();
        }
    }
    void
    visit(UnaryExpr* expr) override
    {
        std::cout << "[DEBUG] Processing UnaryExpr with operator: " << expr->op << std::endl;
        auto operandType = getType(expr->operand.get());
        std::cout << "[DEBUG] Operand type: " << operandType->toString() << std::endl;

        switch (expr->op)
        {
            case UnaryExpr::OP_NEG:
                if (operandType->kind == TypeInfo::Kind::Int ||
                    operandType->kind == TypeInfo::Kind::Float)
                {
                    currentType = operandType;
                    std::cout << "[DEBUG] Valid unary operation, result type: "
                              << currentType->toString() << std::endl;
                }
                else
                {
                    std::cout << "[DEBUG] Invalid unary operation: operand must be numeric"
                              << std::endl;
                    reportError("Unary '-' operand must be numeric");
                    currentType = TypeInfo::Error();
                }
                break;
        }
    }

    void
    visit(BinaryExpr* expr) override
    {
        expr->left->accept(this);
        expr->right->accept(this);

        auto l = expr->left->inferredType;
        auto r = expr->right->inferredType;

        switch (expr->op)
        {
            case BinaryExpr::OP_ADD:
            case BinaryExpr::OP_SUB:
            case BinaryExpr::OP_MUL:
            case BinaryExpr::OP_DIV:
            case BinaryExpr::OP_MOD:
            case BinaryExpr::OP_POW:
                if (l->kind == TypeInfo::Kind::Any || r->kind == TypeInfo::Kind::Any)
                {
                    currentType = TypeInfo::Int();
                    std::cout << "[DEBUG] Any type detected, defaulting to Int" << std::endl;
                }
                else if (isNumeric(l) && isNumeric(r))
                {
                    currentType = promoteNumeric(l, r);
                    std::cout << "[DEBUG] Numeric operation, result type: "
                              << currentType->toString() << std::endl;
                }
                else
                {
                    std::cout << "[DEBUG] Invalid arithmetic operation: operands must be numeric"
                              << std::endl;
                    reportError("Arithmetic operations require numeric operands");
                    currentType = TypeInfo::Error();
                }
                break;
            case BinaryExpr::OP_EQ:
            case BinaryExpr::OP_NEQ:
            case BinaryExpr::OP_LT:
            case BinaryExpr::OP_LE:
            case BinaryExpr::OP_GT:
            case BinaryExpr::OP_GE:
                if (l->kind == TypeInfo::Kind::Any || r->kind == TypeInfo::Kind::Any)
                {
                    currentType = TypeInfo::Bool();
                }
                else if (*l == *r)
                {
                    currentType = TypeInfo::Bool();
                }
                else
                {
                    reportError("Comparison requires operands of same type");
                    currentType = TypeInfo::Error();
                }
                break;
            case BinaryExpr::OP_AND:
            case BinaryExpr::OP_OR:
                if (l->kind == TypeInfo::Kind::Any || r->kind == TypeInfo::Kind::Any)
                {
                    currentType = TypeInfo::Bool();
                }
                else if (l->kind == TypeInfo::Kind::Bool && r->kind == TypeInfo::Kind::Bool)
                {
                    currentType = TypeInfo::Bool();
                }
                else
                {
                    reportError("Logical operators require boolean operands");
                    currentType = TypeInfo::Error();
                }
                break;
            case BinaryExpr::OP_CONCAT:
            case BinaryExpr::OP_CONCAT_WS:
                if (l->kind == TypeInfo::Kind::Any || r->kind == TypeInfo::Kind::Any)
                {
                    currentType = TypeInfo::String();
                }
                else if (l->kind == TypeInfo::Kind::String && r->kind == TypeInfo::Kind::String)
                {
                    currentType = TypeInfo::String();
                }
                else
                {
                    reportError("Concatenation requires string operands");
                    currentType = TypeInfo::Error();
                }
                break;
        }
    }

    void
    visit(AssignExpr* expr) override
    {
        std::cout << "[DEBUG] Processing AssignExpr for variable: " << expr->name << std::endl;
        if (expr->name == "self")
        {
            std::cout << "[DEBUG] Attempt to reassign 'self'" << std::endl;
            reportError("Cannot reassign 'self'");
            currentType = TypeInfo::Error();
            return;
        }

        auto valueType = getType(expr->value.get());
        std::cout << "[DEBUG] Value type: " << valueType->toString() << std::endl;

        if (auto varType = symbols.lookup(expr->name))
        {
            std::cout << "[DEBUG] Found variable with type: " << varType->type->toString()
                      << std::endl;
            if (!varType->isMutable)
            {
                std::cout << "[DEBUG] Variable is immutable" << std::endl;
                reportError("Cannot reassign immutable variable: " + expr->name);
                currentType = TypeInfo::Error();
                return;
            }
            if (*varType->type != *valueType)
            {
                std::cout << "[DEBUG] Type mismatch in assignment" << std::endl;
                reportError("Type mismatch in assignment");
                currentType = TypeInfo::Error();
                return;
            }
            currentType = valueType;
            std::cout << "[DEBUG] Assignment successful, result type: " << currentType->toString()
                      << std::endl;
        }
        else
        {
            std::cout << "[DEBUG] Variable not found in symbol table" << std::endl;
            reportError("Undefined variable: " + expr->name);
            currentType = TypeInfo::Error();
        }
    }

    void
    visit(LetExpr* expr) override
    {
        std::cout << "[DEBUG] Processing LetExpr for variable: " << expr->name << std::endl;

        // Primero evaluar el inicializador para obtener su tipo
        expr->initializer->accept(this);
        auto initType = currentType;
        std::cout << "[DEBUG] Initializer type: " << initType->toString() << std::endl;

        // Registrar la variable con el tipo inferido
        Symbol sym;
        sym.name = expr->name;
        sym.kind = SymbolKind::Variable;
        sym.type = initType;
        sym.isMutable = true;
        symbols.define(expr->name, sym);
        std::cout << "[DEBUG] Variable defined with type: " << initType->toString() << std::endl;

        // Evaluar el cuerpo con la variable en scope
        currentType = getType(expr->body.get());
        std::cout << "[DEBUG] Body type: " << currentType->toString() << std::endl;
    }

    void
    visit(IfExpr* expr) override
    {
        std::cout << "[DEBUG] Processing IfExpr" << std::endl;
        auto condType = getType(expr->condition.get());
        std::cout << "[DEBUG] Condition type: " << condType->toString() << std::endl;

        if (condType->kind != TypeInfo::Kind::Bool)
        {
            std::cout << "[DEBUG] Invalid condition type: must be boolean" << std::endl;
            reportError("If condition must be boolean");
            currentType = TypeInfo::Error();
            return;
        }

        auto thenType = getType(expr->thenBranch.get());
        std::cout << "[DEBUG] Then branch type: " << thenType->toString() << std::endl;

        if (expr->elseBranch)
        {
            auto elseType = getType(expr->elseBranch.get());
            std::cout << "[DEBUG] Else branch type: " << elseType->toString() << std::endl;

            if (*thenType != *elseType)
            {
                std::cout << "[DEBUG] Branch type mismatch" << std::endl;
                reportError("If branches must have same type");
                currentType = TypeInfo::Error();
                return;
            }
        }
        currentType = thenType;
        std::cout << "[DEBUG] If expression type: " << currentType->toString() << std::endl;
    }

    void
    visit(ExprBlock* expr) override
    {
        std::cout << "[DEBUG] Processing ExprBlock" << std::endl;
        std::shared_ptr<TypeInfo> lastType;
        for (const auto& stmt : expr->stmts)
        {
            lastType = getType(stmt.get());
            std::cout << "[DEBUG] Statement type: " << lastType->toString() << std::endl;
        }
        currentType = lastType;
        std::cout << "[DEBUG] Block type: " << currentType->toString() << std::endl;
    }

    void
    visit(CallExpr* expr) override
    {
        std::cout << "[DEBUG] Processing CallExpr for function: " << expr->callee << std::endl;

        // Obtener el tipo de la función
        if (auto funcType = symbols.lookup(expr->callee))
        {
            std::cout << "[DEBUG] Found function with type: " << funcType->type->toString()
                      << std::endl;

            if (funcType->type->isFunction())
            {
                // Procesar los argumentos para inferir sus tipos
                std::vector<std::shared_ptr<TypeInfo>> argTypes;
                for (const auto& arg : expr->args)
                {
                    arg->accept(this);
                    argTypes.push_back(currentType);
                    std::cout << "[DEBUG] Argument type: " << currentType->toString() << std::endl;
                }

                // Actualizar los tipos de los parámetros basado en los argumentos
                auto paramTypes = funcType->type->getParamTypes();
                for (size_t i = 0; i < paramTypes.size() && i < argTypes.size(); ++i)
                {
                    if (paramTypes[i]->kind == TypeInfo::Kind::Any)
                    {
                        paramTypes[i] = argTypes[i];
                        std::cout << "[DEBUG] Updated parameter type to: "
                                  << argTypes[i]->toString() << std::endl;
                    }
                }

                // Actualizar el tipo de la función
                funcType->type = TypeInfo::Function(paramTypes, funcType->type->getReturnType());
                std::cout << "[DEBUG] Updated function type: " << funcType->type->toString()
                          << std::endl;

                // El tipo de retorno de la llamada es el tipo de retorno de la función
                currentType = funcType->type->getReturnType();
                std::cout << "[DEBUG] Call type: " << currentType->toString() << std::endl;
            }
            else
            {
                std::cout << "[DEBUG] Symbol is not a function" << std::endl;
                reportError(expr->callee + " is not a function");
                currentType = TypeInfo::Error();
            }
        }
        else
        {
            std::cout << "[DEBUG] Function not found in symbol table" << std::endl;
            reportError("Undefined function: " + expr->callee);
            currentType = TypeInfo::Error();
        }
    }

    void
    visit(WhileExpr* expr) override
    {
        std::cout << "[DEBUG] Processing WhileExpr" << std::endl;
        auto condType = getType(expr->condition.get());
        std::cout << "[DEBUG] Condition type: " << condType->toString() << std::endl;

        if (condType->kind != TypeInfo::Kind::Bool)
        {
            std::cout << "[DEBUG] Invalid condition type: must be boolean" << std::endl;
            reportError("While condition must be boolean");
            currentType = TypeInfo::Error();
            return;
        }

        getType(expr->body.get());
        currentType = TypeInfo::Void();
        std::cout << "[DEBUG] While expression type: " << currentType->toString() << std::endl;
    }

    void
    visit(NewExpr* expr) override
    {
        std::cout << "[DEBUG] Processing NewExpr for type: " << expr->typeName << std::endl;
        if (auto type = symbols.lookup(expr->typeName))
        {
            std::cout << "[DEBUG] Found type: " << type->type->toString() << std::endl;
            if (type->type->isClass())
            {
                std::vector<std::shared_ptr<TypeInfo>> paramTypes = type->type->getParamTypes();
                std::vector<std::shared_ptr<TypeInfo>> argTypes;

                std::cout << "[DEBUG] Expected " << paramTypes.size() << " constructor parameters"
                          << std::endl;
                std::cout << "[DEBUG] Got " << expr->args.size() << " arguments" << std::endl;

                for (const auto& arg : expr->args)
                {
                    auto argType = getType(arg.get());
                    argTypes.push_back(argType);
                    std::cout << "[DEBUG] Argument type: " << argType->toString() << std::endl;
                }

                for (size_t i = 0; i < paramTypes.size(); i++)
                {
                    if (paramTypes[i]->kind != TypeInfo::Kind::Any &&
                        paramTypes[i]->kind != argTypes[i]->kind)
                    {
                        std::cout << "[DEBUG] Type mismatch in constructor argument " << i
                                  << std::endl;
                        reportError("Constructor argument types don't match");
                        currentType = TypeInfo::Error();
                        return;
                    }
                }
                currentType = type->type;
                std::cout << "[DEBUG] New expression type: " << currentType->toString()
                          << std::endl;
            }
            else
            {
                std::cout << "[DEBUG] Symbol is not a class" << std::endl;
                reportError(expr->typeName + " is not a class");
                currentType = TypeInfo::Error();
            }
        }
        else
        {
            std::cout << "[DEBUG] Type not found in symbol table" << std::endl;
            reportError("Undefined class: " + expr->typeName);
            currentType = TypeInfo::Error();
        }
    }

    void
    visit(SelfExpr* expr) override
    {
        std::cout << "[DEBUG] Processing SelfExpr" << std::endl;
        if (!currentClass)
        {
            std::cout << "[DEBUG] Self used outside of class" << std::endl;
            throw std::runtime_error("Cannot use self outside of class methods");
        }
        expr->inferredType = TypeInfo::UserDefined(currentClass->name);
        std::cout << "[DEBUG] Self type: " << expr->inferredType->toString() << std::endl;
    }

    void
    visit(GetAttrExpr* expr) override
    {
        std::cout << "\n[DEBUG] Processing GetAttrExpr for attribute: " << expr->attrName
                  << std::endl;

        expr->object->accept(this);
        auto objectType = expr->object->inferredType;
        std::cout << "[DEBUG] Object type: " << objectType->toString() << std::endl;

        if (!objectType)
        {
            std::cout << "[DEBUG] Cannot determine object type" << std::endl;
            throw std::runtime_error("Cannot determine type of object");
        }

        if (auto selfExpr = dynamic_cast<SelfExpr*>(expr->object.get()))
        {
            std::cout << "[DEBUG] Found self expression" << std::endl;
            if (!currentClass)
            {
                std::cout << "[DEBUG] Self used outside of class" << std::endl;
                throw std::runtime_error("Cannot use self outside of class methods");
            }
            objectType = currentClass;
            std::cout << "[DEBUG] Self type set to: " << objectType->toString() << std::endl;
        }

        if (!objectType->isClass())
        {
            std::cout << "[DEBUG] Object is not a class instance" << std::endl;
            throw std::runtime_error("Cannot access attributes on non-class instance");
        }

        auto classSymbol = symbols.lookup(objectType->name);
        if (!classSymbol || classSymbol->kind != SymbolKind::Type)
        {
            std::cout << "[DEBUG] Class not found: " << objectType->name << std::endl;
            throw std::runtime_error("Class not found: " + objectType->name);
        }

        std::cout << "[DEBUG] Found class symbol: " << classSymbol->name << std::endl;

        // Buscar el atributo en el TypeInfo de la clase
        if (auto attrType = objectType->getAttributeType(expr->attrName))
        {
            std::cout << "[DEBUG] Found attribute: " << expr->attrName
                      << " of type: " << (*attrType)->toString() << std::endl;
            expr->inferredType = *attrType;
        }
        else
        {
            std::cout << "[DEBUG] Attribute not found: " << expr->attrName << std::endl;
            throw std::runtime_error("Undefined attribute: " + expr->attrName);
        }
    }

    void
    visit(SetAttrExpr* expr) override
    {
        std::cout << "\n[DEBUG] Processing SetAttrExpr for attribute: " << expr->attrName
                  << std::endl;

        // Primero procesar el objeto
        expr->object->accept(this);
        auto objectType = expr->object->inferredType;
        std::cout << "[DEBUG] Object type: " << objectType->toString() << std::endl;

        if (!objectType)
        {
            std::cout << "[DEBUG] Cannot determine object type" << std::endl;
            throw std::runtime_error("Cannot determine type of object");
        }

        if (auto selfExpr = dynamic_cast<SelfExpr*>(expr->object.get()))
        {
            std::cout << "[DEBUG] Found self expression" << std::endl;
            if (!currentClass)
            {
                std::cout << "[DEBUG] Self used outside of class" << std::endl;
                throw std::runtime_error("Cannot use self outside of class methods");
            }
            objectType = currentClass;
            std::cout << "[DEBUG] Self type set to: " << objectType->toString() << std::endl;
        }

        if (!objectType->isClass())
        {
            std::cout << "[DEBUG] Object is not a class instance" << std::endl;
            throw std::runtime_error("Cannot access attributes on non-class instance");
        }

        // Buscar el atributo en el TypeInfo de la clase
        if (auto attrType = objectType->getAttributeType(expr->attrName))
        {
            std::cout << "[DEBUG] Found attribute: " << expr->attrName
                      << " of type: " << (*attrType)->toString() << std::endl;

            // Procesar el valor a asignar
            expr->value->accept(this);
            auto valueType = currentType;
            std::cout << "[DEBUG] Value type: " << valueType->toString() << std::endl;

            // Verificar compatibilidad de tipos
            if (valueType && *attrType && **attrType != *valueType)
            {
                std::cout << "[DEBUG] Type mismatch in attribute assignment" << std::endl;
                throw std::runtime_error("Type mismatch in attribute assignment: expected " +
                                         (*attrType)->toString() + " but got " +
                                         valueType->toString());
            }

            expr->inferredType = valueType;
            std::cout << "[DEBUG] SetAttr type: " << expr->inferredType->toString() << std::endl;
        }
        else
        {
            std::cout << "[DEBUG] Attribute not found: " << expr->attrName << std::endl;
            throw std::runtime_error("Undefined attribute: " + expr->attrName);
        }
    }

    void
    visit(MethodCallExpr* expr) override
    {
        std::cout << "[DEBUG] Processing MethodCallExpr for method: " << expr->methodName
                  << std::endl;

        // Obtener el tipo del objeto
        expr->object->accept(this);
        auto objectType = currentType;
        std::cout << "[DEBUG] Object type: " << objectType->toString() << std::endl;

        // Si el tipo es un tipo definido por el usuario
        if (objectType->isClass())
        {
            std::cout << "[DEBUG] Looking up class: " << objectType->name << std::endl;
            // Buscar el tipo en la tabla de símbolos
            if (auto classSymbol = symbols.lookup(objectType->name))
            {
                std::cout << "[DEBUG] Found class symbol: " << classSymbol->name << std::endl;

                // Buscar el método en el TypeInfo de la clase
                if (auto methodType = objectType->getMethodType(expr->methodName))
                {
                    std::cout << "[DEBUG] Found method: " << expr->methodName
                              << " with type: " << (*methodType)->toString() << std::endl;

                    // Procesar los argumentos
                    for (const auto& arg : expr->args)
                    {
                        arg->accept(this);
                    }

                    // El tipo de retorno será el tipo del método
                    currentType = *methodType;
                }
                else
                {
                    std::cout << "[DEBUG] Method not found: " << expr->methodName << std::endl;
                    throw TypeError("Undefined method: " + expr->methodName);
                }
            }
            else
            {
                throw TypeError("Undefined type: " + objectType->name);
            }
        }
        else
        {
            throw TypeError("Cannot call method on non-class type: " + objectType->toString());
        }

        expr->inferredType = currentType;
        std::cout << "[DEBUG] Method call type: " << currentType->toString() << std::endl;
    }

    void
    visit(BaseCallExpr* expr) override
    {
        std::cout << "\n[DEBUG] Processing BaseCallExpr" << std::endl;
        if (currentClass && currentClass->hasBase())
        {
            std::cout << "[DEBUG] Current class: " << currentClass->name << std::endl;
            std::vector<std::shared_ptr<TypeInfo>> argTypes;
            for (const auto& arg : expr->args)
            {
                auto argType = getType(arg.get());
                argTypes.push_back(argType);
                std::cout << "[DEBUG] Argument type: " << argType->toString() << std::endl;
            }
            if (auto methodType = currentClass->getBaseMethodType(currentMethodName))
            {
                std::cout << "[DEBUG] Found base method with type: " << (*methodType)->toString()
                          << std::endl;
                if ((*methodType)->getParamTypes() != argTypes)
                {
                    std::cout << "[DEBUG] Base method call argument types don't match" << std::endl;
                    reportError("Base method call argument types don't match");
                    currentType = TypeInfo::Error();
                    return;
                }
                currentType = (*methodType)->getReturnType();
                std::cout << "[DEBUG] Base call type: " << currentType->toString() << std::endl;
            }
            else
            {
                std::cout << "[DEBUG] Base method not found: " << currentMethodName << std::endl;
                reportError("Undefined base method: " + currentMethodName);
                currentType = TypeInfo::Error();
            }
        }
        else
        {
            std::cout << "[DEBUG] Base call used outside of class or class has no base"
                      << std::endl;
            reportError("'base' can only be used inside class methods with a base class");
            currentType = TypeInfo::Error();
        }
    }

    void
    visit(ExprStmt* stmt) override
    {
        std::cout << "[DEBUG] Processing ExprStmt" << std::endl;
        getType(stmt->expr.get());
        std::cout << "[DEBUG] Expression type: " << currentType->toString() << std::endl;
    }

    void
    visit(Program* prog) override
    {
        std::cout << "[DEBUG] Processing Program" << std::endl;
        for (const auto& stmt : prog->stmts)
        {
            stmt->accept(this);
        }
    }

    void
    visit(FunctionDecl* stmt) override
    {
        std::cout << "\n[DEBUG] Processing FunctionDecl: " << stmt->name << std::endl;

        // Entrar en el scope de la función
        symbols.enterScope();
        std::cout << "[DEBUG] Entered function scope" << std::endl;

        // Registrar los parámetros con tipo Any inicialmente
        std::vector<std::shared_ptr<TypeInfo>> paramTypes;
        for (const auto& param : stmt->params)
        {
            Symbol paramSym;
            paramSym.name = param;
            paramSym.kind = SymbolKind::Parameter;
            paramSym.type = TypeInfo::Any();  // Tipo inicial Any, se inferirá después
            symbols.define(param, paramSym);
            paramTypes.push_back(paramSym.type);
            std::cout << "[DEBUG] Parameter registered: " << param << std::endl;
        }

        // Procesar el cuerpo para inferir el tipo de retorno
        if (auto exprStmt = dynamic_cast<ExprStmt*>(stmt->body.get()))
        {
            currentType = getType(exprStmt->expr.get());
        }
        else
        {
            currentType = getType(stmt->body.get());
        }
        std::cout << "[DEBUG] Function body type: " << currentType->toString() << std::endl;

        // Crear el tipo de la función con los tipos inferidos
        auto funcType = TypeInfo::Function(paramTypes, currentType);

        // Registrar la función en la tabla de símbolos
        Symbol sym;
        sym.name = stmt->name;
        sym.kind = SymbolKind::Function;
        sym.type = funcType;
        symbols.define(stmt->name, sym);
        std::cout << "[DEBUG] Function registered with type: " << funcType->toString() << std::endl;

        // Salir del scope de la función
        symbols.exitScope();
        std::cout << "[DEBUG] Exited function scope" << std::endl;
    }

    void
    visit(MethodDecl* stmt) override
    {
        std::cout << "[DEBUG] Processing MethodDecl: " << stmt->name << std::endl;

        // Guardar el nombre del método actual
        currentMethodName = stmt->name;

        // Entrar en el scope del método
        symbols.enterScope();
        std::cout << "[DEBUG] Entered method scope for: " << stmt->name << std::endl;

        // Registrar el parámetro 'self' implícito
        Symbol selfSymbol;
        selfSymbol.name = "self";
        selfSymbol.kind = SymbolKind::Parameter;
        selfSymbol.type = currentClass;
        symbols.define("self", selfSymbol);
        std::cout << "[DEBUG] Registered self parameter" << std::endl;

        // Registrar los parámetros del método
        std::vector<std::shared_ptr<TypeInfo>> paramTypes;
        for (const auto& param : stmt->params)
        {
            std::cout << "[DEBUG] Registering parameter: " << param << std::endl;
            Symbol paramSymbol;
            paramSymbol.name = param;
            paramSymbol.kind = SymbolKind::Parameter;

            // Para métodos set, inferir el tipo del parámetro basado en el atributo
            if (stmt->name.substr(0, 3) == "set" && stmt->name.length() > 3)
            {
                std::string attrName = stmt->name.substr(3);
                // Convertir primera letra a minúscula
                attrName[0] = std::tolower(attrName[0]);
                if (auto attrType = currentClass->getAttributeType(attrName))
                {
                    paramSymbol.type = *attrType;
                    std::cout << "[DEBUG] Inferred parameter type from attribute: "
                              << (*attrType)->toString() << std::endl;
                }
                else
                {
                    paramSymbol.type = TypeInfo::Any();
                }
            }
            else
            {
                paramSymbol.type = TypeInfo::Any();
            }

            symbols.define(param, paramSymbol);
            paramTypes.push_back(paramSymbol.type);
        }

        // Procesar el cuerpo del método
        if (stmt->body)
        {
            stmt->body->accept(this);
            stmt->inferredType = currentType;
            std::cout << "[DEBUG] Method body type: " << currentType->toString() << std::endl;
        }

        // Registrar el tipo del método en el TypeInfo de la clase
        auto methodType = TypeInfo::Function(paramTypes, stmt->inferredType);
        currentClass->addMethod(stmt->name, methodType);
        std::cout << "[DEBUG] Method type registered: " << methodType->toString() << std::endl;

        // Salir del scope del método
        symbols.exitScope();
        std::cout << "[DEBUG] Exited method scope for: " << stmt->name << std::endl;

        // Limpiar el nombre del método actual
        currentMethodName = "";
    }

    void
    visit(TypeDecl* stmt) override
    {
        std::cout << "\n[DEBUG] Processing TypeDecl: " << stmt->name << std::endl;

        // Registrar el tipo en la tabla de símbolos
        Symbol typeSymbol;
        typeSymbol.name = stmt->name;
        typeSymbol.kind = SymbolKind::Type;
        typeSymbol.type = TypeInfo::UserDefined(stmt->name);
        symbols.define(stmt->name, typeSymbol);
        std::cout << "[DEBUG] Type registered in symbol table" << std::endl;

        // Entrar en el scope del tipo
        symbols.enterScope();
        std::cout << "[DEBUG] Entered type scope" << std::endl;

        // Guardar el tipo actual como TypeInfo
        currentClass = TypeInfo::UserDefined(stmt->name);

        // Registrar los parámetros del constructor primero
        std::vector<std::shared_ptr<TypeInfo>> paramTypes;
        for (const auto& param : stmt->params)
        {
            std::cout << "[DEBUG] Registering constructor parameter: " << param << std::endl;
            Symbol paramSymbol;
            paramSymbol.name = param;
            paramSymbol.kind = SymbolKind::Parameter;
            paramSymbol.type = TypeInfo::Any();  // Temporalmente asignamos Any
            symbols.define(param, paramSymbol);
            paramTypes.push_back(paramSymbol.type);
        }

        // Registrar el constructor en el TypeInfo
        currentClass->setConstructorParams(paramTypes);

        // Primero registrar todos los atributos con tipo Any
        for (const auto& attr : stmt->attributes)
        {
            std::cout << "[DEBUG] Registering attribute: " << attr->name << std::endl;
            Symbol attrSymbol;
            attrSymbol.name = attr->name;
            attrSymbol.kind = SymbolKind::Attribute;
            attrSymbol.type = TypeInfo::Any();  // Temporalmente asignamos Any
            symbols.define(attr->name, attrSymbol);
            // Agregar el atributo al TypeInfo de la clase
            currentClass->addAttribute(attr->name, attrSymbol.type);
        }

        // Luego evaluar los inicializadores
        for (const auto& attr : stmt->attributes)
        {
            if (attr->initializer)
            {
                attr->initializer->accept(this);
                // Actualizar el tipo del atributo con el tipo inferido
                if (auto symbol = symbols.lookup(attr->name))
                {
                    symbol->type = currentType;
                    // Actualizar el tipo en el TypeInfo de la clase
                    currentClass->addAttribute(attr->name, currentType);
                    std::cout << "[DEBUG] Attribute " << attr->name
                              << " has type: " << symbol->type->toString() << std::endl;
                }
            }
        }

        // Registrar y procesar los métodos
        for (const auto& method : stmt->methods)
        {
            std::cout << "[DEBUG] Registering method: " << method->name << std::endl;
            Symbol methodSymbol;
            methodSymbol.name = method->name;
            methodSymbol.kind = SymbolKind::Method;
            methodSymbol.type = TypeInfo::Any();
            symbols.define(method->name, methodSymbol);

            // Procesar el cuerpo del método
            std::cout << "[DEBUG] Processing method body: " << method->name << std::endl;
            method->accept(this);

            // Guardar el tipo del método en el TypeInfo de la clase
            currentClass->addMethod(method->name, method->inferredType);
            std::cout << "[DEBUG] Method " << method->name
                      << " has type: " << method->inferredType->toString() << std::endl;
        }

        // Actualizar el tipo en la tabla de símbolos con toda la información
        typeSymbol.type = currentClass;
        symbols.update(stmt->name, typeSymbol);

        // Restaurar el tipo actual
        currentClass = nullptr;

        // Salir del scope del tipo
        symbols.exitScope();
        std::cout << "[DEBUG] Exited type scope" << std::endl;
    }

   private:
    std::shared_ptr<TypeInfo> currentType;
    SymbolTable& symbols;
    std::shared_ptr<TypeInfo> currentClass = nullptr;
    std::string currentMethodName;
    std::vector<std::string> errors;

    void
    addBuiltinFunction(const std::string& name,
                       const std::vector<std::shared_ptr<TypeInfo>>& paramTypes,
                       const std::shared_ptr<TypeInfo>& returnType)
    {
        Symbol sym;
        sym.name = name;
        sym.kind = SymbolKind::Function;
        sym.type = TypeInfo::Function(paramTypes, returnType);
        symbols.define(name, sym);
    }

    void
    reportError(const std::string& message)
    {
        error(message);
    }

    bool
    isNumeric(const std::shared_ptr<TypeInfo>& type)
    {
        return type->kind == TypeInfo::Kind::Int || type->kind == TypeInfo::Kind::Float;
    }

    std::shared_ptr<TypeInfo>
    promoteNumeric(const std::shared_ptr<TypeInfo>& t1, const std::shared_ptr<TypeInfo>& t2)
    {
        if (t1->kind == TypeInfo::Kind::Float || t2->kind == TypeInfo::Kind::Float)
        {
            return TypeInfo::Float();
        }
        return TypeInfo::Int();
    }
};


==============================================================
======================SYMBOL=====================================
==============================================================
// symbol.hpp
#pragma once

#include <memory>
#include <string>
#include <variant>

#include "../Types/type_info.hpp"

enum class SymbolKind
{
    Variable,
    Function,
    Type,
    Method,
    TypeParameter,
    Attribute,
    Parameter
};

struct Symbol
{
    std::string name;
    SymbolKind kind;
    std::shared_ptr<TypeInfo> type;
    bool isMutable;

    Symbol() : isMutable(false) {}
    Symbol(const std::string& n, SymbolKind k, std::shared_ptr<TypeInfo> t = nullptr,
           bool m = false)
        : name(n), kind(k), type(t), isMutable(m)
    {
    }
};


==============================================================
======================SYMBOL TABLE=====================================
==============================================================
// symbol_table.hpp
#pragma once

#include <iostream>
#include <memory>
#include <optional>
#include <string>
#include <unordered_map>
#include <vector>

#include "../Types/type_info.hpp"
#include "symbol.hpp"

class SymbolTable
{
   public:
    static SymbolTable&
    getInstance()
    {
        static SymbolTable instance;
        return instance;
    }

    SymbolTable() : currentScope(0)
    {
        // Initialize the global scope
        scopes.push_back(std::unordered_map<std::string, Symbol>());
    }
    ~SymbolTable() = default;

    void
    enterScope()
    {
        std::cout << "Entro al scope desde" << std::endl;
        for (auto& [name, symbol] : scopes[currentScope])
        {
            std::cout << name << " " << symbol.name << std::endl;
        }
        currentScope++;
        scopes.push_back(std::unordered_map<std::string, Symbol>());
    }

    void
    exitScope()
    {
        if (currentScope > 0)
        {
            currentScope--;
        }
    }

    void
    define(const std::string& name, const Symbol& symbol)
    {
        if (currentScope >= 0 && currentScope < scopes.size())
        {
            scopes[currentScope][name] = symbol;
        }
    }

    std::optional<Symbol>
    lookup(const std::string& name) const
    {
        // Search from current scope up to global scope
        for (int i = currentScope; i >= 0; i--)
        {
            auto found = scopes[i].find(name);
            if (found != scopes[i].end())
            {
                return found->second;
            }
        }
        return std::nullopt;
    }

    std::optional<Symbol>
    lookupInCurrentScope(const std::string& name) const
    {
        if (currentScope >= 0 && currentScope < scopes.size())
        {
            auto found = scopes[currentScope].find(name);
            if (found != scopes[currentScope].end())
            {
                return found->second;
            }
        }
        return std::nullopt;
    }

    void
    update(const std::string& name, const Symbol& symbol)
    {
        for (auto it = scopes.rbegin(); it != scopes.rend(); ++it)
        {
            auto found = it->find(name);
            if (found != it->end())
            {
                found->second = symbol;
                return;
            }
        }
    }

    bool
    insert(const std::string& name, const Symbol& symbol)
    {
        if (scopes.empty())
        {
            return false;
        }
        auto& currentScope = scopes.back();
        if (currentScope.find(name) != currentScope.end())
        {
            return false;  // Símbolo ya existe en este scope
        }
        currentScope[name] = symbol;
        return true;
    }

    // Método para imprimir la tabla de símbolos
    void
    print() const
    {
        std::cout << "\nCurrent Scope: " << currentScope << std::endl;
        std::cout << "scopes size: " << scopes.size() << std::endl;

        // Print all scopes
        for (size_t i = 0; i < scopes.size(); i++)
        {
            std::cout << "\nScope " << i << ":" << std::endl;
            std::cout << "Symbols:" << std::endl;

            const auto& scope = scopes[i];
            if (!scope.empty())
            {
                for (const auto& [name, symbol] : scope)
                {
                    std::cout << "  " << name << " (" << symbolKindToString(symbol.kind) << ")";
                    if (symbol.type)
                    {
                        std::cout << " : " << symbol.type->toString();
                    }
                    std::cout << std::endl;
                }
            }
            else
            {
                std::cout << "  No symbols in this scope" << std::endl;
            }
        }
    }

    int
    getCurrentScope() const
    {
        return currentScope;
    }

   private:
    SymbolTable(const SymbolTable&) = delete;
    SymbolTable& operator=(const SymbolTable&) = delete;

    std::vector<std::unordered_map<std::string, Symbol>> scopes;
    int currentScope;

    std::string
    symbolKindToString(SymbolKind kind) const
    {
        switch (kind)
        {
            case SymbolKind::Variable:
                return "Variable";
            case SymbolKind::Function:
                return "Function";
            case SymbolKind::Parameter:
                return "Parameter";
            case SymbolKind::Type:
                return "Type";
            case SymbolKind::TypeParameter:
                return "TypeParameter";
            case SymbolKind::Method:
                return "Method";
            case SymbolKind::Attribute:
                return "Attribute";
            default:
                return "Unknown";
        }
    }
};

==============================================================
======================LEXER=====================================
==============================================================
%option noyywrap
%option noinput nounput
%option yylineno

%{
#include <cstdio>
#include <cstdlib>
#include <cmath>
#include <iostream>
#include <cstring>
#include <string>

#include "../AST/ast.hpp"
#include "../Parser/parser.tab.hpp"

extern int yylineno;

int yycolumn = 1;                   /* columna actual */
/* Antes de cada token, actualizamos:
   - yylloc (para Bison)
   - yycolumn (aumenta por la longitud del token) */
#define YY_USER_ACTION                            \
    yylloc.first_line   = yylineno;               \
    yylloc.first_column = yycolumn;               \
    yylloc.last_line    = yylineno;               \
    yylloc.last_column  = yycolumn + yyleng - 1;  \
    yycolumn += yyleng;

// Función para imprimir información del token
void print_token(const char* token_name, const char* token_value) {
    printf("Token: %-15s Value: %-20s Line: %d, Column: %d\n", 
           token_name, token_value, yylineno, yycolumn - yyleng);
}

// Necesario para evitar conflictos con strdup (definido en <string.h>)
#ifdef strdup
#undef strdup
#endif
%}

%%

<<EOF>>                     { return 0; }
\n                          { yylineno++; yycolumn = 1; }
\r\n                        { yylineno++; yycolumn = 1; }
\r                          { yylineno++; yycolumn = 1; }
[ \t]+                      { /* skip whitespace */ }
"//"[^\n]*                 { /* skip comments */ }                     

[0-9]+(\.[0-9]+)?           {
                              yylval.expr = new NumberExpr(atof(yytext));
                              print_token("NUMBER", yytext);
                              return NUMBER;
                           }

\"([^\"]*)\"                {
                              std::string raw = yytext;
                              // Eliminar comillas del principio y final
                              std::string content = raw.substr(1, raw.length() - 2);
                              yylval.expr = new StringExpr(content);
                              print_token("STRING", content.c_str());
                              return STRING;
                           }

[A-Za-z][A-Za-z0-9_]*  {
    if (strcmp(yytext, "if") == 0)       { print_token("IF", yytext); return IF; }
    if (strcmp(yytext, "else") == 0)     { print_token("ELSE", yytext); return ELSE; }
    if (strcmp(yytext, "elif") == 0)     { print_token("ELIF", yytext); return ELIF; }
    if (strcmp(yytext, "let") == 0)      { print_token("LET", yytext); return LET; }
    if (strcmp(yytext, "in") == 0)       { print_token("IN", yytext); return IN; }
    if (strcmp(yytext, "while") == 0)    { print_token("WHILE", yytext); return WHILE; }
    if (strcmp(yytext, "for") == 0)      { print_token("FOR", yytext); return FOR; }
    if (strcmp(yytext, "type") == 0)     { print_token("TYPE", yytext); return TYPE; }
    if (strcmp(yytext, "self") == 0)     { print_token("SELF", yytext); return SELF; }
    if (strcmp(yytext, "new") == 0)      { print_token("NEW", yytext); return NEW; }
    if (strcmp(yytext, "base") == 0)     { print_token("BASE", yytext); return BASE; }
    if (strcmp(yytext, "inherits") == 0) { print_token("INHERITS", yytext); return INHERITS; }
    if (strcmp(yytext, "true") == 0)     { 
        yylval.expr = new BooleanExpr(true);
        print_token("TRUE", yytext);
        return TRUE; 
    }
    if (strcmp(yytext, "false") == 0)    { 
        yylval.expr = new BooleanExpr(false);
        print_token("FALSE", yytext);
        return FALSE; 
    }
    if (strcmp(yytext,"function") == 0)  { print_token("FUNCTION", yytext); return FUNCTION; }

    // Si no es ninguna palabra reservada, entonces es IDENT
    yylval.str = strdup(yytext);
    print_token("IDENT", yytext);
    return IDENT;
}

                    
\,                          { print_token("COMMA", ","); return COMMA; }
\+                          { print_token("PLUS", "+"); return PLUS; }
\-                          { print_token("MINUS", "-"); return MINUS; }
\*                          { print_token("MULT", "*"); return MULT; }
\/                          { print_token("DIV", "/"); return DIV; }
\**                         { print_token("POW", "**"); return POW; }
\(                          { print_token("LPAREN", "("); return LPAREN; }
\)                          { print_token("RPAREN", ")"); return RPAREN; }
\;                          { print_token("SEMICOLON", ";"); return SEMICOLON; }
\%                          { print_token("MOD", "%"); return MOD; }
"<="                        { print_token("LE", "<="); return LE; }
">="                        { print_token("GE", ">="); return GE; }
"=="                        { print_token("EQ", "=="); return EQ; }
\!=                         { print_token("NEQ", "!="); return NEQ; }
"<"                         { print_token("LESS_THAN", "<"); return LESS_THAN; }
">"                         { print_token("GREATER_THAN", ">"); return GREATER_THAN; }
"||"                        { print_token("OR", "||"); return OR; }
"&&"                        { print_token("AND", "&&"); return AND; }  
"="                         { print_token("ASSIGN", "="); return ASSIGN; }
\{                          { print_token("LBRACE", "{"); return LBRACE; }
\}                          { print_token("RBRACE", "}"); return RBRACE; }
":="                        { print_token("ASSIGN_DESTRUCT", ":="); return ASSIGN_DESTRUCT; }
"=>"                        { print_token("ARROW", "=>"); return ARROW; }
"@"                         { print_token("CONCAT", "@"); return CONCAT; }
"@@"                        { print_token("CONCAT_WS", "@@"); return CONCAT_WS; }
\.                          { print_token("DOT", "."); return DOT; }
\:                          { print_token("COLON", ":"); return COLON; }
\^                          { print_token("POW", "^"); return POW; }
.                           {
                              fprintf(stderr, "Caracter no reconocido: %s en la línea %d\n", yytext, yylineno);
                           }

%%

==============================================================
======================PARSER=====================================
==============================================================
%error-verbose
%locations
%debug

%{
  /* Definir manualmente YYLTYPE */
  typedef struct YYLTYPE {
      int first_line;
      int first_column;
      int last_line;
      int last_column;
  } YYLTYPE;
  #define YYLTYPE_IS_DECLARED 1

  #include <cstdio>
  #include <cstdlib>
  #include "AST/ast.hpp"
  #include "Types/type_info.hpp"
  extern Program* rootAST;
  extern int yylex(void);
  extern FILE* yyin;
  extern int yylineno;

  /* 1) Función interna que maneja ubicación detallada */
  static void yyerror_loc(YYLTYPE *locp, const char *msg) {
      // Asegurarnos de que la línea no sea mayor que el número real de líneas
      int line = locp->first_line;
      if (line < 1) line = 1;
      
      // Obtener el número de línea actual del lexer
      extern int yylineno;
      if (line > yylineno) {
          line = yylineno;
      }
      
      std::fprintf(stderr,
          "Error de parseo en línea %d, columna %d: %s\n",
          line,
          locp->first_column,
          msg);
      
      // Información adicional de debug
      extern char* yytext;
      std::fprintf(stderr, "Token actual: '%s'\n", yytext ? yytext : "NULL");
      
      std::exit(EXIT_FAILURE);
  }

  /* 2) Firma que Bison invoca CON ubicación (2 args) */
  void yyerror(YYLTYPE *locp, const char *msg) {
      yyerror_loc(locp, msg);
  }

  /* 3) Firma que Bison invoca SIN ubicación (1 arg) */
  void yyerror(const char *msg) {
      /* `yylloc` es la variable global que Bison mantiene */
      extern YYLTYPE yylloc;
      yyerror_loc(&yylloc, msg);
  }

  #include <string>
  #include <vector>
  #include <memory>
  #include <iostream>
  #include <cstdlib>
  #include <cstring>

  void yyerror(const char* s);
  int yylex();

  extern char* yytext;

  // Inicialización por defecto para TypeInfo
  std::shared_ptr<TypeInfo> defaultTypeInfo() {
      return TypeInfo::Void();
  }
%}



%union {
  Expr* expr;
  Stmt* stmt;
  Program* prog;
  std::vector<StmtPtr>* stmts;
  std::vector<ExprPtr>* expr_list;
  std::vector<std::string>* str_list;
  std::pair<std::string, Expr*>* binding;
  std::vector<std::pair<std::string, Expr*>>* bindings;
  std::pair<
      std::vector<std::unique_ptr<AttributeDecl>>,
      std::vector<std::unique_ptr<MethodDecl>>
    >* mems;
  std::pair<AttributeDecl*, MethodDecl*>* member_pair; 
    AttributeDecl* attribute_decl;
    MethodDecl* method_decl;
    std::shared_ptr<TypeInfo>* type_info;
    std::vector<std::shared_ptr<TypeInfo>>* type_info_list;
    char* str;
}

%start input

%type  <stmt> stmt
%type  <expr> expr 
%type  <prog> input
%type  <prog> program
%type <stmts> stmt_list
%type <binding> binding
%type <str_list> ident_list
%type <bindings> binding_list 
%type <expr> if_expr
%type <expr_list> argument_list
%type <stmt> type_decl
%type <mems> member_list
%type <member_pair> member
%type <attribute_decl> attribute
%type <method_decl> method
%type <type_info> type
%type <type_info_list> type_list


%token LET IN 
%token WHILE FOR
%token <str> IDENT
%token IF ELSE ELIF
%token FUNCTION ARROW
%token ASSIGN ASSIGN_DESTRUCT
%token TYPE DOT SELF NEW INHERITS BASE
%token <expr> TRUE FALSE NUMBER STRING
%token PLUS MINUS MULT DIV MOD POW CONCAT CONCAT_WS
%token LE GE EQ NEQ LESS_THAN GREATER_THAN OR AND
%token LPAREN RPAREN LBRACE RBRACE COMMA SEMICOLON COLON
%token INT FLOAT BOOL VOID


%right ASSIGN_DESTRUCT
%right ASSIGN
%left OR
%left AND
%left EQ NEQ
%left CONCAT CONCAT_WS
%left LESS_THAN GREATER_THAN LE GE
%left PLUS MINUS
%left MULT DIV MOD
%right POW
%left UMINUS

%%

input:
    program { rootAST = $1; }
  

program:
    /* vacío */      { $$ = new Program(); }
  | program stmt SEMICOLON
    {
      $1->stmts.emplace_back( StmtPtr($2) );
      $$ = $1;
    }
  | program expr SEMICOLON
    {
      $1->stmts.emplace_back( StmtPtr(new ExprStmt(ExprPtr($2))) );
      $$ = $1;
    }
;    

binding_list:
    binding {
          $$ = new std::vector<std::pair<std::string, Expr*>>();
          $$->push_back(*$1);
          delete $1;
      }
    | binding_list COMMA binding {
          $1->push_back(*$3);
          delete $3;
          $$ = $1;
      }
;

binding:
      IDENT ASSIGN expr {
          $$ = new std::pair<std::string, Expr*>(std::string($1), $3);
          free($1);
      }
;

stmt:
    expr  {
        (yyval.stmt) = (new ExprStmt(ExprPtr((yyvsp[(1) - (1)].expr))));
    }
    | FUNCTION IDENT LPAREN ident_list RPAREN COLON type LBRACE stmt_list RBRACE {
        std::vector<std::string> args = $4 ? std::move(*$4) : std::vector<std::string>();
        delete $4;
        auto block = std::make_unique<Program>();
        block->stmts = std::move(*$9);
        delete $9;
        std::vector<std::optional<std::shared_ptr<TypeInfo>>> param_types;
        (yyval.stmt) = static_cast<Stmt*>(new FunctionDecl(std::string($2), std::move(args), std::move(block), std::move(param_types)));
        delete $7;
        free($2);
    }
  | FUNCTION IDENT LPAREN ident_list RPAREN LBRACE stmt_list RBRACE {
        std::vector<std::string> args = $4 ? std::move(*$4) : std::vector<std::string>();
        delete $4;
        auto block = std::make_unique<Program>();
        block->stmts = std::move(*$7);
        delete $7;
        std::vector<std::optional<std::shared_ptr<TypeInfo>>> param_types;
        (yyval.stmt) = static_cast<Stmt*>(new FunctionDecl(std::string($2), std::move(args), std::move(block), std::move(param_types)));
        free($2);
    }
    | FUNCTION IDENT LPAREN ident_list RPAREN ARROW expr {
        std::vector<std::string> args = $4 ? std::move(*$4) : std::vector<std::string>();
        delete $4;
        std::vector<std::optional<std::shared_ptr<TypeInfo>>> param_types;
        (yyval.stmt) = static_cast<Stmt*>(new FunctionDecl(std::string($2), std::move(args), 
            std::make_unique<ExprStmt>(ExprPtr($7)), std::move(param_types)));
        free($2);
    }
    | FUNCTION IDENT LPAREN RPAREN ARROW expr {
        std::vector<std::string> args;
        std::vector<std::optional<std::shared_ptr<TypeInfo>>> param_types;
        (yyval.stmt) = static_cast<Stmt*>(new FunctionDecl(std::string($2), std::move(args), 
            std::make_unique<ExprStmt>(ExprPtr($6)), std::move(param_types)));
        free($2);
    }
    | type_decl
;    



stmt_list:
    /* vacío */ { $$ = new std::vector<StmtPtr>(); }
  | stmt_list stmt SEMICOLON { 
      $1->push_back(StmtPtr($2)); 
      $$ = $1; 
    }
  | stmt_list expr SEMICOLON { 
      $1->push_back(StmtPtr(new ExprStmt(ExprPtr($2)))); 
      $$ = $1; 
    }
;

ident_list:
      /* vacío */ { $$ = new std::vector<std::string>(); }
    | IDENT { $$ = new std::vector<std::string>(); $$->push_back($1); free($1); }
    | ident_list COMMA IDENT { $1->push_back($3); free($3); $$ = $1; }
;

expr:
    NUMBER { std::cout << "Evaluated expression statement" << std::endl; $$ = $1; }
  | STRING { $$ = $1; }
  | TRUE { $$ = $1; }
  | FALSE { $$ = $1; }
  | IDENT { $$ = new VariableExpr($1); free($1); }
  | expr PLUS expr { $$ = new BinaryExpr(BinaryExpr::OP_ADD, ExprPtr($1), ExprPtr($3)); }
  | expr MINUS expr { $$ = new BinaryExpr(BinaryExpr::OP_SUB, ExprPtr($1), ExprPtr($3)); }
  | expr MULT expr { $$ = new BinaryExpr(BinaryExpr::OP_MUL, ExprPtr($1), ExprPtr($3)); }
  | expr DIV expr { $$ = new BinaryExpr(BinaryExpr::OP_DIV, ExprPtr($1), ExprPtr($3)); }
  | expr MOD expr { $$ = new BinaryExpr(BinaryExpr::OP_MOD, ExprPtr($1), ExprPtr($3)); }
  | expr POW expr { $$ = new BinaryExpr(BinaryExpr::OP_POW, ExprPtr($1), ExprPtr($3)); }
  | expr CONCAT expr { $$ = new BinaryExpr(BinaryExpr::OP_CONCAT, ExprPtr($1), ExprPtr($3)); }
  | expr CONCAT_WS expr { $$ = new BinaryExpr(BinaryExpr::OP_CONCAT_WS, ExprPtr($1), ExprPtr($3)); }
  | expr LESS_THAN expr { $$ = new BinaryExpr(BinaryExpr::OP_LT, ExprPtr($1), ExprPtr($3)); }
  | expr GREATER_THAN expr { $$ = new BinaryExpr(BinaryExpr::OP_GT, ExprPtr($1), ExprPtr($3)); }
  | expr LE expr { $$ = new BinaryExpr(BinaryExpr::OP_LE, ExprPtr($1), ExprPtr($3)); }
  | expr GE expr { $$ = new BinaryExpr(BinaryExpr::OP_GE, ExprPtr($1), ExprPtr($3)); }
  | expr EQ expr { $$ = new BinaryExpr(BinaryExpr::OP_EQ, ExprPtr($1), ExprPtr($3)); }
  | expr NEQ expr { $$ = new BinaryExpr(BinaryExpr::OP_NEQ, ExprPtr($1), ExprPtr($3)); }
  | expr AND expr { $$ = new BinaryExpr(BinaryExpr::OP_AND, ExprPtr($1), ExprPtr($3)); }
  | expr OR expr { $$ = new BinaryExpr(BinaryExpr::OP_OR, ExprPtr($1), ExprPtr($3)); }
  | MINUS expr %prec UMINUS { $$ = new UnaryExpr(UnaryExpr::OP_NEG, ExprPtr($2)); }
  | IDENT LPAREN argument_list RPAREN { 
      std::vector<ExprPtr> args;
      for (auto& arg : *$3) {
          args.push_back(std::move(arg));
      }
      $$ = new CallExpr($1, std::move(args)); 
      free($1); 
      delete $3; 
  }
  | IDENT LPAREN RPAREN { $$ = new CallExpr($1, std::vector<ExprPtr>()); free($1); }
  | NEW IDENT LPAREN argument_list RPAREN {
      std::vector<ExprPtr> args;
      for (auto& arg : *$4) {
          args.push_back(std::move(arg));
      }
      $$ = new NewExpr($2, std::move(args));
      free($2);
      delete $4;
  }
  | NEW IDENT LPAREN RPAREN {
      $$ = new NewExpr($2, std::vector<ExprPtr>());
      free($2);
  }
  | expr DOT IDENT LPAREN argument_list RPAREN {
      std::vector<ExprPtr> args;
      for (auto& arg : *$5) {
          args.push_back(std::move(arg));
      }
      $$ = new MethodCallExpr(ExprPtr($1), $3, std::move(args));
      free($3);
      delete $5;
  }
  | expr DOT IDENT LPAREN RPAREN {
      $$ = new MethodCallExpr(ExprPtr($1), $3, std::vector<ExprPtr>());
      free($3);
  }
  | BASE LPAREN argument_list RPAREN {
      std::vector<ExprPtr> args;
      for (auto& arg : *$3) {
          args.push_back(std::move(arg));
      }
      $$ = new BaseCallExpr(std::move(args));
      delete $3;
  }
  | BASE LPAREN RPAREN {
      $$ = new BaseCallExpr(std::vector<ExprPtr>());
  }
  | LET binding_list IN expr { 
      std::vector<std::pair<std::string, ExprPtr>> bindings;
      for (auto& binding : *$2) {
          bindings.push_back({binding.first, ExprPtr(binding.second)});
      }
      $$ = new LetExpr(bindings[0].first, std::move(bindings[0].second), 
                      std::make_unique<ExprStmt>(ExprPtr($4)));
      delete $2; 
  }
  | if_expr
  
  | WHILE expr LBRACE stmt_list RBRACE { 
      auto block = ExprPtr(new ExprBlock(std::move(*$4)));
      $$ = new WhileExpr(ExprPtr($2), std::move(block)); 
      delete $4;
  }
  | LBRACE stmt_list RBRACE { 
      $$ = new ExprBlock(std::move(*$2)); 
      delete $2;
  }
  | LPAREN expr RPAREN { $$ = $2; }
    | expr DOT IDENT {
        $$ = new GetAttrExpr(ExprPtr($1), $3);
        free($3);
    }
  | expr DOT IDENT ASSIGN_DESTRUCT expr {
        $$ = new SetAttrExpr(ExprPtr($1), $3, ExprPtr($5));
        free($3);
    }
  | expr DOT IDENT LPAREN argument_list RPAREN {
        $$ = new MethodCallExpr(ExprPtr($1), $3, std::move(*$5));
        delete $5;
        free($3);
    }
  | SELF {
        $$ = new SelfExpr();
    }  
  | BASE LPAREN RPAREN {
        $$ = new BaseCallExpr({});
    }  

;

;

if_expr:
    IF LPAREN expr RPAREN expr ELSE expr {
        $$ = new IfExpr(ExprPtr($3), ExprPtr($5), ExprPtr($7));
    }
    | IF LPAREN expr RPAREN LBRACE stmt_list RBRACE ELSE LBRACE stmt_list RBRACE { 
      auto ifBlock = ExprPtr(new ExprBlock(std::move(*$6)));
      auto elseBlock = ExprPtr(new ExprBlock(std::move(*$10)));
      $$ = new IfExpr(ExprPtr($3), std::move(ifBlock), std::move(elseBlock)); 
      delete $6;
      delete $10;
  }
  | IF LPAREN expr RPAREN LBRACE stmt_list RBRACE { 
      auto ifBlock = ExprPtr(new ExprBlock(std::move(*$6)));
      $$ = new IfExpr(ExprPtr($3), std::move(ifBlock), nullptr); 
      delete $6;
  }
;

argument_list:
    /* empty */
    { (yyval.expr_list) = new std::vector<ExprPtr>(); }
    | expr
    {
        (yyval.expr_list) = new std::vector<ExprPtr>();
        (yyval.expr_list)->emplace_back(ExprPtr((yyvsp[(1) - (1)].expr)));
      }
    | argument_list COMMA expr
    {
        (yyvsp[(1) - (3)].expr_list)->emplace_back(ExprPtr((yyvsp[(3) - (3)].expr)));
        (yyval.expr_list) = (yyvsp[(1) - (3)].expr_list);
      }
; 

type_decl:
    TYPE IDENT LPAREN ident_list RPAREN INHERITS IDENT LPAREN argument_list RPAREN LBRACE member_list RBRACE {
        (yyval.stmt) = static_cast<Stmt*>(new TypeDecl(
            std::string($2),
            std::move(*$4),
            std::move($12->first),
            std::move($12->second),
            std::string($7),
            std::move(*$9)
        ));
        delete $4; delete $9; delete $12;
        free($2); free($7);
    }
  | TYPE IDENT INHERITS IDENT LPAREN argument_list RPAREN LBRACE member_list RBRACE {
        (yyval.stmt) = static_cast<Stmt*>(new TypeDecl(
            std::string($2),
            {},
            std::move($9->first),
            std::move($9->second),
            std::string($4),
            std::move(*$6)
        ));
        delete $6; delete $9;
        free($2); free($4);
    }
| TYPE IDENT INHERITS IDENT LBRACE member_list RBRACE {
        (yyval.stmt) = static_cast<Stmt*>(new TypeDecl(
            std::string($2),
            {}, // sin parámetros propios
            std::move($6->first),
            std::move($6->second),
            std::string($4), // tipo base
            {} // sin baseArgs explícitos: herencia implícita
        ));
        delete $6;
        free($2); free($4);
    }
  | TYPE IDENT LPAREN ident_list RPAREN LBRACE member_list RBRACE {
        (yyval.stmt) = static_cast<Stmt*>(new TypeDecl(
            std::string($2),
            std::move(*$4),
            std::move($7->first),
            std::move($7->second)
        ));
        delete $4; delete $7;
        free($2);
    }
  | TYPE IDENT LBRACE member_list RBRACE {
        (yyval.stmt) = static_cast<Stmt*>(new TypeDecl(
            std::string($2),
            {},
            std::move($4->first),
            std::move($4->second)
        ));
        delete $4; free($2);
    }
;

member_list:
    /* empty */ { 
        auto* pair = new std::pair<
            std::vector<std::unique_ptr<AttributeDecl>>,
            std::vector<std::unique_ptr<MethodDecl>>
        >();
        (yyval.mems) = pair;
    }
    | member_list member {
        if ($2->first) {
            $1->first.push_back(std::unique_ptr<AttributeDecl>($2->first));
        } else {
            $1->second.push_back(std::unique_ptr<MethodDecl>($2->second));
        }
        delete $2;
        (yyval.mems) = $1;
    }
;

member:
    attribute SEMICOLON {
        auto* pair = new std::pair<AttributeDecl*, MethodDecl*>();
        pair->first = $1;
        (yyval.member_pair) = pair;
    }
    | method SEMICOLON {
        auto* pair = new std::pair<AttributeDecl*, MethodDecl*>();
        pair->second = $1;
        (yyval.member_pair) = pair;
    }
;

attribute:
    IDENT ASSIGN expr {
        (yyval.attribute_decl) = static_cast<AttributeDecl*>(new AttributeDecl($1, ExprPtr($3)));
        free($1);
    }
;

method:
    IDENT LPAREN ident_list RPAREN ARROW expr {
        std::vector<std::string> args = $3 ? std::move(*$3) : std::vector<std::string>();
        delete $3;
        (yyval.method_decl) = static_cast<MethodDecl*>(new MethodDecl($1, std::move(args), StmtPtr(new ExprStmt(ExprPtr($6)))));
        free($1);
    }
    | IDENT LPAREN ident_list RPAREN LBRACE stmt_list RBRACE {
        std::vector<std::string> args = $3 ? std::move(*$3) : std::vector<std::string>();
        delete $3;
        auto block = std::make_unique<Program>();
        block->stmts = std::move(*$6);
        delete $6;
        (yyval.method_decl) = static_cast<MethodDecl*>(new MethodDecl($1, std::move(args), StmtPtr(std::move(block))));
        free($1);
    }
    | IDENT LPAREN RPAREN ARROW expr {
        std::vector<std::string> args;
        (yyval.method_decl) = static_cast<MethodDecl*>(new MethodDecl($1, std::move(args), StmtPtr(new ExprStmt(ExprPtr($5)))));
        free($1);
    }
;

type:
    INT { (yyval.type_info) = new std::shared_ptr<TypeInfo>(TypeInfo::Int()); }
    | FLOAT { (yyval.type_info) = new std::shared_ptr<TypeInfo>(TypeInfo::Float()); }
    | BOOL { (yyval.type_info) = new std::shared_ptr<TypeInfo>(TypeInfo::Bool()); }
    | STRING { (yyval.type_info) = new std::shared_ptr<TypeInfo>(TypeInfo::String()); }
    | VOID { (yyval.type_info) = new std::shared_ptr<TypeInfo>(TypeInfo::Void()); }
    | IDENT { (yyval.type_info) = new std::shared_ptr<TypeInfo>(TypeInfo::UserDefined($1)); free($1); }
    | LPAREN type RPAREN { (yyval.type_info) = $2; }
    | type ARROW type { 
        std::vector<std::shared_ptr<TypeInfo>> params;
        params.push_back(*$1);
        (yyval.type_info) = new std::shared_ptr<TypeInfo>(TypeInfo::Function(params, *$3));
        delete $1;
        delete $3;
    }
    | LPAREN type_list RPAREN ARROW type {
        (yyval.type_info) = new std::shared_ptr<TypeInfo>(TypeInfo::Function(*$2, *$5));
        delete $2;
        delete $5;
    }
;

type_list:
    type { 
        (yyval.type_info_list) = new std::vector<std::shared_ptr<TypeInfo>>();
        (yyval.type_info_list)->push_back(*$1);
        delete $1;
    }
    | type_list COMMA type {
        $1->push_back(*$3);
        delete $3;
        (yyval.type_info_list) = $1;
    }
;

%%
==============================================================
======================VALUE=====================================
==============================================================
// value.hpp
#pragma once

#ifndef VALUE_HPP
#define VALUE_HPP

#include <iostream>
#include <memory>
#include <sstream>
#include <string>
#include <variant>

class RangeValue;
class RangeIterator;
struct Instance;

class Value
{
   public:
    using Storage = std::variant<double, std::string, bool, std::shared_ptr<RangeValue>,
                                 std::shared_ptr<RangeIterator>, std::shared_ptr<Instance>>;

    Value() : val(0.0) {}
    Value(double d) : val(d) {}
    Value(const std::string& s) : val(s) {}
    Value(bool b) : val(b) {}
    Value(std::shared_ptr<RangeValue> rv) : val(rv) {}
    Value(std::shared_ptr<RangeIterator> it) : val(it) {}
    Value(std::shared_ptr<Instance> i) : val(i) {}

    ~Value() = default;

    bool
    isNumber() const
    {
        return std::holds_alternative<double>(val);
    }
    bool
    isString() const
    {
        return std::holds_alternative<std::string>(val);
    }
    bool
    isBool() const
    {
        return std::holds_alternative<bool>(val);
    }
    bool
    isRange() const
    {
        return std::holds_alternative<std::shared_ptr<RangeValue>>(val);
    }
    bool
    isIterable() const
    {
        return std::holds_alternative<std::shared_ptr<RangeIterator>>(val);
    }
    bool
    isInstance() const
    {
        return std::holds_alternative<std::shared_ptr<Instance>>(val);
    }

    double
    asNumber() const
    {
        return std::get<double>(val);
    }
    const std::string&
    asString() const
    {
        return std::get<std::string>(val);
    }
    bool
    asBool() const
    {
        return std::get<bool>(val);
    }
    std::shared_ptr<RangeValue>
    asRange() const
    {
        if (!isRange())
            throw std::runtime_error("Value no es RangeValue");
        return std::get<std::shared_ptr<RangeValue>>(val);
    }
    std::shared_ptr<RangeIterator>
    asIterable() const
    {
        if (!isIterable())
            throw std::runtime_error("Value no es RangeIterator");
        return std::get<std::shared_ptr<RangeIterator>>(val);
    }
    std::shared_ptr<Instance>
    asInstance() const
    {
        return std::get<std::shared_ptr<Instance>>(val);
    }

    std::string
    toString() const
    {
        if (isString())
        {
            return asString();
        }
        if (isNumber())
        {
            // Convierte double a string sin ceros inútiles
            std::ostringstream oss;
            oss << asNumber();
            return oss.str();
        }
        if (isBool())
        {
            return asBool() ? "true" : "false";
        }
        if (isRange())
        {
            return "<range>";
        }
        if (isIterable())
        {
            return "<iterator>";
        }
        return "<unknown>";
    }

   private:
    Storage val;
    friend std::ostream& operator<<(std::ostream& os, const Value& v);
};

inline std::ostream&
operator<<(std::ostream& os, const Value& v)
{
    if (v.isNumber())
    {
        os << v.asNumber();
    }
    else if (v.isBool())
    {
        os << (v.asBool() ? "true" : "false");
    }
    else if (v.isString())
    {
        os << "\"" << v.asString() << "\"";
    }
    else if (v.isRange())
    {
        os << "<range>";
    }
    else if (v.isIterable())
    {
        os << "<iterator>";
    }
    else
    {
        os << "<unknown>";
    }

    return os;
}

#endif

==============================================================
======================ENV_FRAME=====================================
==============================================================
#pragma once

#include <memory>
#include <stdexcept>
#include <string>
#include <unordered_map>

#include "../Value/value.hpp"

struct EnvFrame
{
    // mapa local de nombre→valor
    std::unordered_map<std::string, Value> locals;

    // puntero shared a un frame padre (nullptr si es el global)
    std::shared_ptr<EnvFrame> parent;

    // Constructor: recibe el frame padre
    explicit EnvFrame(std::shared_ptr<EnvFrame> p = nullptr) : parent(std::move(p)) {}

    // Buscar recursivamente un nombre en esta cadena de frames.
    // Si no se halla en ningún nivel, lanza excepción.
    Value
    get(const std::string& name) const
    {
        auto it = locals.find(name);
        if (it != locals.end())
        {
            return it->second;
        }
        if (parent)
        {
            return parent->get(name);
        }
        throw std::runtime_error("Variable no definida: " + name);
    }

    // Asignar un valor a un nombre en el frame adecuado:
    // - Si el nombre existe en el mapa local, sobrescribir aquí.
    // - Si no existe localmente, pero existe en algún padre, propagar la asignación al padre donde
    // esté originalmente.
    // - Si no existe en ningún lado, crearla en este frame (nivel actual).
    void
    set(const std::string& name, const Value& v)
    {
        if (locals.count(name))
        {
            locals[name] = v;
            return;
        }

        if (parent && parent->existsInChain(name))
        {
            parent->set(name, v);
            return;
        }

        locals[name] = v;
    }

    // Verificar si un nombre existe en esta cadena de frames (local o ancestros).
    bool
    existsInChain(const std::string& name) const
    {
        if (locals.count(name))
            return true;
        if (parent)
            return parent->existsInChain(name);
        return false;
    }
};

==============================================================
======================EVALUATOR=====================================
==============================================================
// evaluator.hpp
#ifndef EVALUATOR_HPP
#define EVALUATOR_HPP

#include <stdio.h>

#include <cmath>
#include <iostream>
#include <stdexcept>
#include <unordered_map>

#include "../AST/ast.hpp"
#include "../Value/enumerable.hpp"
#include "../Value/iterable.hpp"
#include "../Value/value.hpp"
#include "env_frame.hpp"
struct Instance;

struct Instance
{
    std::shared_ptr<EnvFrame> attrs;
    TypeDecl* typeDef;
    std::shared_ptr<Instance> self;  // Referencia a sí mismo

    Instance() : attrs(std::make_shared<EnvFrame>(nullptr)), typeDef(nullptr), self(nullptr) {}
};

struct EvaluatorVisitor : StmtVisitor, ExprVisitor
{
    Value lastValue{0.0};
    std::shared_ptr<Instance> currentSelf;

    std::shared_ptr<EnvFrame> env;
    std::unordered_map<std::string, FunctionDecl*> functions;
    std::unordered_map<std::string, TypeDecl*> types;
    std::shared_ptr<EnvFrame> globalEnv;
    std::string currentMethodName;
    TypeDecl* currentType = nullptr;  // Para seguimiento en métodos

    EvaluatorVisitor()
    {
        globalEnv = env = std::make_shared<EnvFrame>(nullptr);
        types["Object"] = new TypeDecl("Object", {}, {}, {});

        // Agregar constantes matemáticas al entorno global
        globalEnv->locals["PI"] = Value(M_PI);
        globalEnv->locals["E"] = Value(M_E);
    }

    // Programa: recorre stmt a stmt
    void
    visit(Program* p) override
    {
        // Primero registrar TODAS las funciones
        for (auto& s : p->stmts)
        {
            if (auto* fd = dynamic_cast<FunctionDecl*>(s.get()))
            {
                fd->accept(this);  // esto registra la función en el mapa
            }
        }

        // Luego ejecutar todo (incluyendo funciones si hay recursión)
        for (auto& s : p->stmts)
        {
            if (!dynamic_cast<FunctionDecl*>(s.get()))
            {
                s->accept(this);
            }
        }
    }

    // StmtVisitor:

    void
    visit(ExprStmt* e) override
    {
        e->expr->accept(this);
    }

    // ExprVisitor:
    void
    visit(NumberExpr* e) override
    {
        lastValue = Value(e->value);
    }

    void
    visit(StringExpr* e) override
    {
        lastValue = Value(e->value);
    }

    void
    visit(BooleanExpr* expr) override
    {
        lastValue = Value(expr->value);
    }

    void
    visit(UnaryExpr* e) override
    {
        e->operand->accept(this);
        lastValue = Value(-lastValue.asNumber());
    }

    void
    visit(BinaryExpr* e) override
    {
        e->left->accept(this);
        Value l = lastValue;
        e->right->accept(this);
        Value r = lastValue;

        // Debug: imprimir los valores de la expresión binaria
        std::cout << "Debug: BinaryExpr " << l.toString() << " " << e->op << " " << r.toString()
                  << std::endl;

        if (l.isInstance() || r.isInstance())
        {
            throw std::runtime_error("no compararemos instancias aun.");
        }
        switch (e->op)
        {
            case BinaryExpr::OP_ADD:
                if (!l.isNumber() || !r.isNumber())
                {
                    throw std::runtime_error("ambos miembros en una suma deben ser numeros");
                }
                lastValue = Value(l.asNumber() + r.asNumber());
                break;
            case BinaryExpr::OP_SUB:
                std::cout << "[DEBUG] BinaryExpr: OP_SUB" << std::endl;
                std::cout << "[DEBUG] l: " << l.toString() << std::endl;
                std::cout << "[DEBUG] r: " << r.toString() << std::endl;
                if (!l.isNumber() || !r.isNumber())
                {
                    throw std::runtime_error("ambos miembros en una resta deben ser numeros");
                }
                lastValue = Value(l.asNumber() - r.asNumber());
                break;
            case BinaryExpr::OP_MUL:
                if (!l.isNumber() || !r.isNumber())
                {
                    throw std::runtime_error(
                        "ambos miembros en una multiplicacion deben ser numeros");
                }
                lastValue = Value(l.asNumber() * r.asNumber());
                break;
            case BinaryExpr::OP_DIV:
                if (!l.isNumber() || !r.isNumber())
                {
                    throw std::runtime_error("ambos miembros en una division deben ser numeros");
                }
                lastValue = Value(l.asNumber() / r.asNumber());
                break;
            case BinaryExpr::OP_MOD:
                if (!l.isNumber() || !r.isNumber())
                {
                    throw std::runtime_error(
                        "ambos miembros en una operacion de resto deben ser numeros");
                }
                lastValue = Value(fmod(l.asNumber(), r.asNumber()));
                break;
            case BinaryExpr::OP_POW:
                if (!l.isNumber() || !r.isNumber())
                {
                    throw std::runtime_error("ambos miembros en una potencia deben ser numeros");
                }
                lastValue = Value(pow(l.asNumber(), r.asNumber()));
                break;
            case BinaryExpr::OP_LT:
                if (!l.isNumber() || !r.isNumber())
                {
                    throw std::runtime_error("ambos miembros en una comparacion deben ser numeros");
                }
                lastValue = Value(l.asNumber() < r.asNumber() ? true : false);
                break;
            case BinaryExpr::OP_GT:
                if (!l.isNumber() || !r.isNumber())
                {
                    throw std::runtime_error("ambos miembros en una comparacion deben ser numeros");
                }
                lastValue = Value(l.asNumber() > r.asNumber() ? true : false);
                break;
            case BinaryExpr::OP_LE:
                if (!l.isNumber() || !r.isNumber())
                {
                    throw std::runtime_error("ambos miembros en una comparacion deben ser numeros");
                }
                lastValue = Value(l.asNumber() <= r.asNumber() ? true : false);
                break;
            case BinaryExpr::OP_GE:
                if (!l.isNumber() || !r.isNumber())
                {
                    throw std::runtime_error("ambos miembros en una comparacion deben ser numeros");
                }
                lastValue = Value(l.asNumber() >= r.asNumber() ? true : false);
                break;
            case BinaryExpr::OP_EQ:
                if (l.isNumber() && r.isNumber())
                {
                    lastValue = Value(l.asNumber() == r.asNumber() ? true : false);
                }
                else if (l.isString() && r.isString())
                {
                    lastValue = Value(l.asString() == r.asString() ? true : false);
                }
                else if (l.isBool() && r.isBool())
                {
                    lastValue = Value(l.asBool() == r.asBool() ? true : false);
                }
                else
                {
                    throw std::runtime_error(
                        "ambos miembros en una comparacion deben ser del mismo tipo");
                }
                break;
            case BinaryExpr::OP_NEQ:
                if (l.isNumber() && r.isNumber())
                {
                    lastValue = Value(l.asNumber() != r.asNumber() ? true : false);
                }
                else if (l.isString() && r.isString())
                {
                    lastValue = Value(l.asString() != r.asString() ? true : false);
                }
                else if (l.isBool() && r.isBool())
                {
                    lastValue = Value(l.asBool() != r.asBool() ? true : false);
                }
                else
                {
                    throw std::runtime_error(
                        "ambos miembros en una comparacion deben ser del mismo tipo");
                }
                break;
            case BinaryExpr::OP_OR:
                if (!l.isBool() || !r.isBool())
                    throw std::runtime_error("or requiere booleanos");
                lastValue = Value(l.asBool() || r.asBool() ? true : false);
                break;
            case BinaryExpr::OP_AND:
                if (!l.isBool() || !r.isBool())
                    throw std::runtime_error("and requiere booleanos");
                lastValue = Value(l.asBool() && r.asBool() ? true : false);
                break;
            case BinaryExpr::OP_CONCAT:
            {
                std::string ls = l.toString();
                std::string rs = r.toString();
                lastValue = Value(ls + rs);
            }
            break;
            case BinaryExpr::OP_CONCAT_WS:
            {
                std::string ls = l.toString();
                std::string rs = r.toString();
                lastValue = Value(ls + " " + rs);
            }
            break;
            default:
                throw std::runtime_error("Operador desconocido");
        }
    }

    void
    visit(CallExpr* e) override
    {
        // std::cout << "Entrando a CallExpr: " << e->callee << std::endl;
        std::vector<Value> args;
        for (auto& arg : e->args)
        {
            arg->accept(this);
            args.push_back(lastValue);
        }

        // Funciones definidas por el usuario
        auto it = functions.find(e->callee);
        if (it != functions.end())
        {
            FunctionDecl* f = it->second;

            if (f->params.size() != args.size())
            {
                throw std::runtime_error("Número incorrecto de argumentos para función: " +
                                         f->name);
            }

            // Guardar entorno actual
            auto oldEnv = env;
            env = std::make_shared<EnvFrame>(oldEnv);

            // Asignar parámetros
            for (size_t i = 0; i < f->params.size(); ++i)
            {
                env->locals[f->params[i]] = args[i];
            }

            // Evaluar cuerpo
            f->body->accept(this);

            // Restaurar entorno
            env = std::move(oldEnv);

            return;
        }

        // Funciones nativas del lenguaje
        if (e->callee == "range")
        {
            if (args.size() != 2 || !args[0].isNumber() || !args[1].isNumber())
            {
                throw std::runtime_error("range() espera 2 argumentos numéricos");
            }
            double start = args[0].asNumber();
            double end = args[1].asNumber();
            auto rv = std::make_shared<RangeValue>(start, end);
            lastValue = Value(rv);
            return;
        }
        else if (e->callee == "iter")
        {
            if (args.size() != 1)
            {
                throw std::runtime_error("iter() espera 1 argumento");
            }
            if (args[0].isRange())
            {
                auto rv = args[0].asRange();
                auto itr = rv->iter();
                lastValue = Value(itr);
                return;
            }
            throw std::runtime_error("iter(): el argumento no es Enumerable");
        }
        else if (e->callee == "next")
        {
            if (args.size() != 1 || !args[0].isIterable())
            {
                throw std::runtime_error("next() espera 1 argumento Iterable");
            }
            auto itr = args[0].asIterable();
            bool hay = itr->next();
            lastValue = Value(hay);
            return;
        }
        else if (e->callee == "current")
        {
            if (args.size() != 1 || !args[0].isIterable())
            {
                throw std::runtime_error("current() espera 1 argumento Iterable");
            }
            auto itr = args[0].asIterable();
            lastValue = itr->current();
            return;
        }
        else if (e->callee == "print")
        {
            if (args.empty())
                throw std::runtime_error("print espera al menos 1 argumento");
            std::cout << args[0] << std::endl;
            lastValue = args[0];  // Asegurarnos de que print retorne el valor que imprime
            return;
        }
        else if (e->callee == "sqrt")
        {
            if (args.size() != 1)
                throw std::runtime_error("sqrt() espera 1 argumento");
            lastValue = Value(std::sqrt(args[0].asNumber()));
            return;
        }
        else if (e->callee == "log")
        {
            if (args.size() == 1)
            {
                lastValue = Value(std::log(args[0].asNumber()));
                return;
            }
            else if (args.size() == 2)
            {
                double base = args[0].asNumber();
                double x = args[1].asNumber();
                if (base <= 0 || base == 1)
                    throw std::runtime_error("Base inválida para log()");
                if (x <= 0)
                    throw std::runtime_error("Argumento inválido para log()");
                lastValue = Value(std::log(x) / std::log(base));
                return;
            }
            else
            {
                throw std::runtime_error("log() espera 1 o 2 argumentos");
            }
        }
        else if (e->callee == "sin")
        {
            if (args.size() != 1)
                throw std::runtime_error("sin() espera 1 argumento");
            lastValue = Value(std::sin(args[0].asNumber()));
            return;
        }
        else if (e->callee == "cos")
        {
            if (args.size() != 1)
                throw std::runtime_error("cos() espera 1 argumento");
            lastValue = Value(std::cos(args[0].asNumber()));
            return;
        }
        else if (e->callee == "rand")
        {
            lastValue = Value(static_cast<double>(rand()) / RAND_MAX);
            return;
        }
        else
        {
            // Intentar buscar la constante en el entorno global
            try
            {
                lastValue = globalEnv->get(e->callee);
                return;
            }
            catch (const std::runtime_error&)
            {
                throw std::runtime_error("Función o constante desconocida: " + e->callee);
            }
        }
    }

    // for variable declarations
    void
    visit(VariableExpr* expr) override
    {
        // get() buscará en este frame y en los padres
        lastValue = env->get(expr->name);
    }

    // let in expressions
    void
    visit(LetExpr* expr) override
    {
        // 1) Evaluar la expresión del inicializador
        expr->initializer->accept(this);
        Value initVal = lastValue;

        // 2) Abrir un nuevo frame (scope hijo)
        auto oldEnv = env;  // guardar el frame padre
        env = std::make_shared<EnvFrame>(oldEnv);

        // 3) Insertar la variable en el mapa local
        env->locals[expr->name] = initVal;

        // 4) Evaluar el cuerpo (es un Stmt)
        expr->body->accept(static_cast<StmtVisitor*>(this));
        Value result = lastValue;

        // 5) Al salir, restaurar el frame anterior
        env = std::move(oldEnv);

        // 6) El valor resultante de la expresión let es el valor devuelto
        lastValue = result;
    }

    // destructive assignment
    void
    visit(AssignExpr* expr) override
    {
        // Antes de asignar, evaluamos la expresión de la derecha:
        expr->value->accept(this);
        Value newVal = lastValue;

        // Verificar que exista en alguna parte (no crear nuevas automáticamente):
        if (!env->existsInChain(expr->name))
        {
            throw std::runtime_error("No se puede asignar a variable no declarada: " + expr->name);
        }
        // Llamamos a set() para que reasigne en el frame correspondiente:
        env->set(expr->name, newVal);
        lastValue = newVal;  // Devolvemos el nuevo valor asignado
    }

    // functions declaration
    void
    visit(FunctionDecl* f) override
    {
        if (functions.count(f->name))
            throw std::runtime_error("Funcion ya definida: " + f->name);
        functions[f->name] = f;
    }

    // if-else
    void
    visit(IfExpr* e) override
    {
        e->condition->accept(this);
        if (!lastValue.isBool())
        {
            throw std::runtime_error("La condición de un if debe ser booleana");
        }

        if (lastValue.asBool())
        {
            e->thenBranch->accept(this);
        }
        else
        {
            e->elseBranch->accept(this);
        }
    }

    void
    visit(ExprBlock* b) override
    {
        // std::cout << "Entrando a ExprBlock" << std::endl;
        // 1) Abrir un nuevo frame (scope hijo) antes de entrar al bloque
        auto oldEnv = env;
        env = std::make_shared<EnvFrame>(oldEnv);

        // 2) Evaluar cada sentencia dentro del bloque con este nuevo frame
        for (auto& stmt : b->stmts)
        {
            // std::cout << "Evaluando statement en bloque" << std::endl;
            stmt->accept(this);
        }

        // 3) Restaurar el frame anterior al salir del bloque
        env = std::move(oldEnv);
        // std::cout << "Saliendo de ExprBlock" << std::endl;
        // Mantenemos el último valor evaluado
    }

    void
    visit(WhileExpr* expr) override
    {
        Value result;
        while (true)
        {
            expr->condition->accept(this);
            if (!lastValue.isBool())
                throw std::runtime_error("La condición de un while debe ser booleana");
            if (!lastValue.asBool())
                break;

            expr->body->accept(this);
            result = lastValue;  // Guardamos el último valor evaluado
        }
        lastValue = result;  // Devolvemos el último valor en lugar de void
    }

    void
    visit(TypeDecl* t) override
    {
        if (types.count(t->name))
        {
            throw std::runtime_error("Tipo redefinido: " + t->name);
        }
        types[t->name] = t;
    }

    void
    visit(MethodDecl* m) override
    {
        // Los métodos se registran en el tipo, no en el entorno
    }

    void
    visit(NewExpr* e) override
    {
        auto instance = std::make_shared<Instance>();
        TypeDecl* type = types.at(e->typeName);
        instance->typeDef = type;
        instance->attrs = std::make_shared<EnvFrame>(globalEnv);
        instance->self = instance;  // Establecer la referencia a sí mismo

        // 0. Herencia implícita de argumentos si no se definieron
        if (type->params.empty() && type->baseArgs.empty() && type->baseType != "Object")
        {
            TypeDecl* parent = types.at(type->baseType);
            if (!parent->getParams().empty())
            {
                type->params = parent->getParams();
                type->baseArgs.clear();
                for (const auto& param : parent->getParams())
                {
                    type->baseArgs.push_back(std::make_unique<VariableExpr>(param));
                }
            }
        }

        // 1. Evaluar argumentos de construcción
        {
            const auto& paramNames = type->getParams();
            if (paramNames.size() != e->args.size())
                throw std::runtime_error("Número de argumentos inválido para " + e->typeName);

            env = instance->attrs;
            for (size_t i = 0; i < paramNames.size(); ++i)
            {
                e->args[i]->accept(this);
                env->locals[paramNames[i]] = lastValue;
            }
        }

        // 2. Si hereda de otro tipo, instanciar atributos del padre
        if (type->baseType != "Object")
        {
            TypeDecl* base = types.at(type->baseType);
            auto baseEnv = std::make_shared<EnvFrame>(instance->attrs);

            // Verificar que cantidad de argumentos coincida
            if (base->getParams().size() != type->baseArgs.size())
                throw std::runtime_error("Número incorrecto de argumentos en llamada a base: " +
                                         type->baseType);

            // Evaluar argumentos del base usando el entorno actual
            env = baseEnv;
            for (size_t i = 0; i < base->getParams().size(); ++i)
            {
                type->baseArgs[i]->accept(this);
                env->locals[base->getParams()[i]] = lastValue;
            }

            // Inicializar atributos del padre
            for (auto& attr : base->attributes)
            {
                attr->initializer->accept(this);
                instance->attrs->locals[attr->name] = lastValue;
            }
        }

        // 3. Inicializar atributos del tipo actual
        env = instance->attrs;
        for (auto& attr : type->attributes)
        {
            attr->initializer->accept(this);
            env->locals[attr->name] = lastValue;
        }

        lastValue = Value(instance);
    }

    void
    visit(SelfExpr* expr) override
    {
        if (!currentSelf)
        {
            throw std::runtime_error("Cannot use self outside of class methods");
        }
        lastValue = Value(currentSelf);
    }

    void
    visit(GetAttrExpr* e) override
    {
        e->object->accept(this);
        auto object = lastValue;
        if (auto instance = std::dynamic_pointer_cast<Instance>(object.asInstance()))
        {
            try
            {
                auto val = instance->attrs->get(e->attrName);
                std::cout << "[DEBUG] GetAttrExpr: instance attr '" << e->attrName
                          << "' = " << val.toString() << std::endl;
                lastValue = val;
            }
            catch (const std::runtime_error&)
            {
                throw std::runtime_error("Undefined attribute: " + e->attrName);
            }
        }
        else if (auto selfExpr = dynamic_cast<SelfExpr*>(e->object.get()))
        {
            if (!currentSelf)
                throw std::runtime_error("Cannot use self outside of class methods");
            try
            {
                auto val = currentSelf->attrs->get(e->attrName);
                std::cout << "[DEBUG] GetAttrExpr: self attr '" << e->attrName
                          << "' = " << val.toString() << std::endl;
                lastValue = val;
            }
            catch (const std::runtime_error&)
            {
                throw std::runtime_error("Undefined attribute: " + e->attrName);
            }
        }
        else
        {
            throw std::runtime_error("Cannot access attributes on non-class instance");
        }
    }

    void
    visit(SetAttrExpr* e) override
    {
        // Evaluar el objeto primero y GUARDAR el resultado
        e->object->accept(this);
        auto instanceVal = lastValue;
        auto instance = instanceVal.asInstance();  // sin dynamic cast

        // Evaluar el valor a asignar
        e->value->accept(this);
        auto newValue = lastValue;

        // Validar y asignar
        if (!instance)
            throw std::runtime_error("SetAttrExpr: objeto no es una instancia válida");

        auto currentValue = instance->attrs->get(e->attrName);
        std::cout << "[DEBUG] SetAttrExpr: instance attr '" << e->attrName
                  << "' before = " << currentValue.toString() << std::endl;

        if (newValue.isNumber())
        {
            instance->attrs->set(e->attrName, newValue);
            std::cout << "[DEBUG] SetAttrExpr: instance attr '" << e->attrName
                      << "' after = " << newValue.toString() << std::endl;
            lastValue = newValue;
        }
        else
        {
            throw std::runtime_error("Cannot assign non-numeric value to attribute");
        }
    }

    void
    visit(BaseCallExpr* e) override
    {
        auto selfVal = env->get("self");
        if (!selfVal.isInstance())
            throw std::runtime_error("base() requiere instancia");

        auto instance = selfVal.asInstance();
        if (currentMethodName.empty())
            throw std::runtime_error("base() fuera de contexto de método");

        TypeDecl* current = instance->typeDef;
        MethodDecl* method = nullptr;

        while (current->baseType != "Object")
        {
            current = types.at(current->baseType);
            for (auto& m : current->methods)
            {
                if (m->name == currentMethodName)
                {
                    method = m.get();
                    break;
                }
            }
            if (method)
                break;
        }

        if (!method)
            throw std::runtime_error("base(): método base no encontrado");

        auto oldEnv = env;
        env = std::make_shared<EnvFrame>(instance->attrs);
        env->locals["self"] = Value(instance);

        auto oldMethod = currentMethodName;
        currentMethodName = method->name;
        method->body->accept(this);
        currentMethodName = oldMethod;
        env = oldEnv;
    }

    void
    visit(MethodCallExpr* e) override
    {
        // Evaluar el objeto de la llamada (ej: a.setx() → 'a')
        e->object->accept(this);
        auto object = lastValue;

        // Verifica que es una instancia
        auto instance = object.asInstance();
        if (!instance)
        {
            throw std::runtime_error("Cannot call methods on non-class instance");
        }

        // Busca el método en el tipo correspondiente
        MethodDecl* method = nullptr;
        for (const auto& m : instance->typeDef->methods)
        {
            if (m->name == e->methodName)
            {
                method = m.get();
                break;
            }
        }

        if (!method)
        {
            throw std::runtime_error("Undefined method: " + e->methodName);
        }

        // Guardar entorno y self anteriores
        auto oldEnv = env;
        auto oldSelf = currentSelf;

        // Establecer entorno del método y currentSelf
        env = std::make_shared<EnvFrame>(instance->attrs);
        currentSelf = instance;

        // ⚠️ Evalúa los argumentos DESPUÉS de establecer el entorno y currentSelf
        std::vector<Value> args;
        for (const auto& arg : e->args)
        {
            arg->accept(this);
            args.push_back(lastValue);
        }

        // Inyectar argumentos como variables locales
        for (size_t i = 0; i < method->params.size(); ++i)
        {
            if (i < args.size())
            {
                env->locals[method->params[i]] = args[i];
            }
        }

        // Ejecutar el cuerpo del método
        method->body->accept(this);
        Value result = lastValue;

        // Restaurar entorno y self anteriores
        env = oldEnv;
        currentSelf = oldSelf;

        lastValue = result;
    }
};
#endif