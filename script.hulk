//====================================================
//==============EXPRESIONES ARITEMTICAS =========
//====================================================-
//42;
//-42;
//((((1 + 2) ^ 3) * 4) / 5);
//====================================================
// =========== STRINGS ===============
//====================================================

//print("Hello World");
//print("The message is Hello World");
//print("The meaning of life is " @ 42);


//====================================================
//========== FUNCIONES BUILT IN =============
//====================================================

//print(sin(2 * PI) ^ 2 + cos(3 * PI / log(4, 64)));
//{
//    print(42);
//    print(sin(PI/2));
//    print("Hello World");
//};


//====================================================
//========== FUNCIONES =============
//====================================================

//function s(a,b)=>a;
//print(s(2));
//function tan(x: Number): Number => sin(x) / cos(x);
//function cot(x: Number): Number => 1 / tan(x);

//function fib(n) => if (n == 0 || n == 1) 1 else fib(n-1) + fib(n-2);
//function tan(x) => sin(x) / cos(x);
//function cot(x) => 1 / tan(x);
// print(tan(PI) ** 2 + cot(PI) ** 2);
//function operate(x, y) {
//    print(x + y);
//    print(x - y);
//    print(x * y);
//    print(x / y);
//};
//print(sin(90*3.14/180));
//function h(x,y) => x+y;
//function g(x,y)=> h(x,y);
//function f(x,y)=> g(x,y);
//


//====================================================
//========== CLASES =============
//====================================================
// Test file for type declaration semantic checking

//type Point(x,y) {
//    x = x;
//    y = y;
//
//    getX() => self.x;
//    getY() => self.y;
//
//    setX(x) => self.x := x;
//    setY(y) => self.y := y;
//};
//
//type PolarPoint(phi, rho) inherits Point(rho * sin(phi), rho * cos(phi)){
//    rho() => sqrt(self.getX() ^ 2 + self.getY() ^ 2);
//    // ...
//};
//let pt = new PolarPoint(3,4) in {
//    pt.setX(2);
//    pt.setY(4);
//    print("rho: " @ pt.rho());
//};

//type Person(firstname, lastname) {
//    firstname = firstname;
//    lastname = lastname;
//    name() => self.firstname @@ self.lastname;
//};
//
//type Knight inherits Person {
//    name() => "Sir" @@ base();
//};
//
//let p = new Knight("Phil", "Collins") in
//    print(p.name()); 


//
//type vector (a:Number,b:Number) inherits Point {
//
//};

//type Person(firstname, lastname) {
//    firstname = firstname;
//    lastname = lastname;
//
//    name() => self.firstname @@ self.lastname;
//};
//
//type Knight inherits Person {
//    name() => "Sir" @@ base();
//}
//
//let p = new Knight("Phil", "Collins") in
//    print(p.name()); // prints 'Sir Phil Collins'

// Test attribute access
//let p = new Point() in {
//    print(p.getX());
//    print(p.getY());
//    p.setX(10);
//    p.setY(20);
//    print(p.getX() + 4);
//    print(p.getY());
//}; 
//type Pointa (x,y) {
//    x = x;
//    y = y;
//
//    getX() => self.x;
//    getY() => self.y;
//
//    setX(x) => self.x := x;
//    setY(y) => self.y := y;
//};
//
//let pt = new Pointa(3,4) in
//    print("x: " @ pt.getX() @ "; y: " @ pt.getY());

//====================================================
//========== IF ELSE =============
//====================================================

//if(3<8) 4 else 5;




//====================================================
//========== Let in  =============
//====================================================
//let x = 42 in print(x);
//let x:String = "lala", y : Number = 9 in print (y@x);

//let a = 4 in while(a>1){
//    print(a);
//    a:=a-1;
//};

//====================================================
//========== CICLOS  =============
//====================================================

//for ( i in range(1,3)){
//    print(i);
//};


//====================================================
//==========Type Conforming  =============
//====================================================

// Test file for type conforming (<=) relationship
// This file demonstrates all the conforming rules in HULK

// ====================================================
// REGLA 1: Todo tipo conforma a Object
// ====================================================
type Animal() {
    name() => "Animal";
};

type Dog() inherits Animal {
    bark() => "Woof!";
};

type Cat() inherits Animal {
    meow() => "Meow!";
};

// ====================================================
// REGLA 2: Todo tipo conforma a sí mismo
// ====================================================
//let dog1: Dog = new Dog() in
//let dog2: Dog = new Dog() in
//    print("Dog conforms to Dog: " @ (dog1 == dog2));

// ====================================================
// REGLA 3: Si T1 hereda T2 entonces T1 <= T2
// ====================================================
let dog: Animal = new Dog() in  // Dog <= Animal
let cat: Animal = new Cat() in {
    print("Dog conforms to Animal: " @ (dog.name() == "Animal"));
    print(dog.bark());
};



// ====================================================
// REGLA 4: Solo Number, String, Boolean conforman a sí mismos
// ====================================================
//let x: Number = 42 in
//let y: String = "hello" in
//let z: Boolean = true in
//    print("Numbers conform to Number: " @ (x == 42));

// ====================================================
// REGLA 5: Transitividad - Si T1 <= T2 y T2 <= T3, entonces T1 <= T3
// ====================================================
//type Mammal() inherits Animal {
//    warmBlooded() => true;
//};
//
//type Canine() inherits Mammal {
//    packAnimal() => true;
//};
//
//let wolf: Animal = new Canine() in  // Canine <= Mammal <= Animal
//    print("Canine conforms to Animal through inheritance: " @ (wolf.name() == "Animal"));

// ====================================================
// REGLA 6: Lowest Common Ancestor (LCA)
// ====================================================
// En una expresión como: if (condition) new Dog() else new Cat()
// El tipo resultante debe ser Animal (LCA de Dog y Cat)
//
//let condition = true in
//let result = if (condition) new Dog() else new Cat() in
//    print("LCA of Dog and Cat is Animal: " @ (result.name() == "Animal"));
//
// ====================================================
// REGLA 7: Verificación de tipos en asignaciones
// ====================================================
//let animals: [Animal] = [new Dog(), new Cat(), new Canine()] in
//    print("Array of different animal types works with Animal type");

// ====================================================
// REGLA 8: Verificación de tipos en parámetros de función
// ====================================================
//function makeSound(animal: Animal) => animal.name();
//
//let dogSound = makeSound(new Dog()) in
//let catSound = makeSound(new Cat()) in
//    print("Function accepts subtypes: " @ dogSound @ " and " @ catSound);

// ====================================================
// REGLA 9: Verificación de tipos en retorno de función
// ====================================================
//function getRandomAnimal() => if (true) new Dog() else new Cat();
//
//let randomAnimal: Animal = getRandomAnimal() in
//    print("Function returns LCA type: " @ randomAnimal.name());

// ====================================================
// REGLA 10: Verificación de tipos en expresiones binarias
// ====================================================
//let animal1: Animal = new Dog() in
//let animal2: Animal = new Cat() in
//let areEqual = animal1 == animal2 in  // Debe ser válido porque ambos conforman a Animal
//    print("Comparison between subtypes is valid: " @ areEqual); 
//